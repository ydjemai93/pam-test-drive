type BaseConfigurableProp = {
    /**
     * When building `configuredProps`, make sure to use this field as the key when
     * setting the prop value.
     */
    name: string;
    type: string;
    /**
     * Value to use as an input label. In cases where `type` is "app", should load
     * the app via `getApp`, etc. and show `app.name` instead.
     */
    label?: string;
    description?: string;
    optional?: boolean;
    disabled?: boolean;
    /**
     * If true, should not expose this prop to the user.
     */
    hidden?: boolean;
    /**
     * If true, call `configureComponent` for this prop to load remote options.
     * It is safe, and preferred, given a returned list of
     * { label: string; value: any } objects to set the prop
     * value to { __lv: { label: string; value: any } }. This way, on load, you
     * can access label for the value without necessarily reloading these options.
     */
    remoteOptions?: boolean;
    /**
     * If true, calls to `configureComponent` for this prop support receiving a
     * `query` parameter to filter remote options.
     */
    useQuery?: boolean;
    /**
     * If true, after setting a value for this prop, a call to `reloadComponentProps` is
     * required as the component has dynamic configurable props dependent on this
     * one.
     */
    reloadProps?: boolean;
    /**
     * If true, you must save the configured prop value as a "label-value" object
     * which should look like: { __lv: { label: string; value: any } }
     * because the execution needs to access the label.
     */
    withLabel?: boolean;
};
type LabelValueOption<T> = {
    label: string;
    value: T;
};
type Defaultable<T, SingleT = T> = {
    default?: T;
    options?: SingleT[] | Array<LabelValueOption<SingleT>>;
};
type ConfigurablePropAlert = BaseConfigurableProp & {
    type: "alert";
    alertType?: "info" | "neutral" | "warning" | "error";
    content: string;
};
type ConfigurablePropAny = BaseConfigurableProp & {
    type: "any";
} & Defaultable<any>;
type ConfigurablePropApp = BaseConfigurableProp & {
    type: "app";
    app: string;
};
type ConfigurablePropBoolean = BaseConfigurableProp & {
    type: "boolean";
} & Defaultable<boolean>;
type ConfigurablePropInteger = BaseConfigurableProp & {
    type: "integer";
    min?: number;
    max?: number;
} & Defaultable<number>;
type ConfigurablePropObject = BaseConfigurableProp & {
    type: "object";
} & Defaultable<object>;
type ConfigurablePropString = BaseConfigurableProp & {
    type: "string";
    secret?: boolean;
} & Defaultable<string>;
type ConfigurablePropStringArray = BaseConfigurableProp & {
    type: "string[]";
    secret?: boolean;
} & Defaultable<string[], string>;
type TimerInterval = {
    intervalSeconds: number;
};
type TimerCron = {
    cron: string;
};
type ConfigurablePropTimer = BaseConfigurableProp & {
    type: "$.interface.timer";
    static?: TimerInterval | TimerCron;
} & Defaultable<TimerInterval | TimerCron>;
type ConfigurablePropApphook = BaseConfigurableProp & {
    type: "$.interface.apphook";
    appProp: string;
    eventNames?: Array<string>;
    remote?: boolean;
    static?: Array<unknown>;
};
type ConfigurablePropIntegerArray = BaseConfigurableProp & {
    type: "integer[]";
    min?: number;
    max?: number;
} & Defaultable<number[], number>;
type ConfigurablePropHttp = BaseConfigurableProp & {
    type: "$.interface.http";
    customResponse?: boolean;
};
type ConfigurablePropDb = BaseConfigurableProp & {
    type: "$.service.db";
};
type ConfigurablePropSql = BaseConfigurableProp & {
    type: "sql";
    auth?: {
        app: string;
    };
} & Defaultable<string>;
type ConfigurablePropAirtableBaseId = BaseConfigurableProp & {
    type: "$.airtable.baseId";
    appProp: string;
};
type ConfigurablePropAirtableTableId = BaseConfigurableProp & {
    type: "$.airtable.tableId";
    baseIdProp: string;
};
type ConfigurablePropAirtableViewId = BaseConfigurableProp & {
    type: "$.airtable.viewId";
    tableIdProp: string;
};
type ConfigurablePropAirtableFieldId = BaseConfigurableProp & {
    type: "$.airtable.fieldId";
    tableIdProp: string;
};
type ConfigurablePropDiscordChannel = BaseConfigurableProp & {
    type: "$.discord.channel";
    appProp: string;
};
type ConfigurablePropDiscordChannelArray = BaseConfigurableProp & {
    type: "$.discord.channel[]";
    appProp: string;
};
type ConfigurableProp = ConfigurablePropAirtableBaseId | ConfigurablePropAirtableFieldId | ConfigurablePropAirtableTableId | ConfigurablePropAirtableViewId | ConfigurablePropAlert | ConfigurablePropAny | ConfigurablePropApp | ConfigurablePropApphook | ConfigurablePropBoolean | ConfigurablePropDb | ConfigurablePropDiscordChannel | ConfigurablePropDiscordChannelArray | ConfigurablePropHttp | ConfigurablePropInteger | ConfigurablePropIntegerArray | ConfigurablePropObject | ConfigurablePropSql | ConfigurablePropString | ConfigurablePropStringArray | ConfigurablePropTimer;
type ConfigurableProps = Readonly<ConfigurableProp[]>;
type PropValue<T extends ConfigurableProp["type"]> = T extends "alert" ? never : T extends "any" ? any : T extends "app" ? {
    authProvisionId: string;
} : T extends "boolean" ? boolean : T extends "integer" ? number : T extends "object" ? object : T extends "string" ? string : T extends "string[]" ? string[] : T extends "sql" ? {
    app: string;
    query: string;
    params: unknown[];
} : never;
type ConfiguredProps<T extends ConfigurableProps> = {
    [K in T[number] as K["name"]]?: PropValue<K["type"]>;
};
type V1Component<T extends ConfigurableProps = any> = {
    name: string;
    key: string;
    version: string;
    configurable_props: T;
    description?: string;
    component_type?: string;
};
type V1DeployedComponent<T extends ConfigurableProps = any> = {
    id: string;
    owner_id: string;
    component_id: string;
    configurable_props: T;
    configured_props: ConfiguredProps<T>;
    active: boolean;
    created_at: number;
    updated_at: number;
    name: string;
    name_slug: string;
    callback_observations?: unknown;
    /**
     * The URL to the HTTP interface of this component, if it has one.
     */
    endpoint_url?: string;
};
type V1EmittedEvent = {
    /**
     * The event's payload.
     */
    e: Record<string, any>;
    /**
     * The event's type (set to "emit" currently).
     */
    k: string;
    /**
     * The event's timestamp in epoch milliseconds.
     */
    ts: number;
    /**
     * The event's unique ID.
     */
    id: string;
};

type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
type ExternalUserId = RequireAtLeastOne<{
    /**
     * Your end user ID, for whom you're configuring the component.
     */
    externalUserId: string;
    /**
     * @deprecated Use `externalUserId` instead.
     */
    userId: string;
}, "externalUserId" | "userId">;
type RequestInit = globalThis.RequestInit;
/**
 * Options for creating a server-side client.
 * This is used to configure the BackendClient instance.
 */
type ClientOpts = {
    /**
     * The environment in which the server client is running (e.g., "production",
     * "development").
     */
    environment?: string;
    /**
     * The API host URL. Used by Pipedream employees. Defaults to
     * "api.pipedream.com" if not provided.
     */
    apiHost?: string;
    /**
     * Base domain for workflows. Used for custom domains:
     * https://pipedream.com/docs/workflows/domains
     */
    workflowDomain?: string;
};
/**
 * Basic ID information of a Pipedream app.
 */
type AppInfo = {
    /**
     * ID of the app. Only applies for OAuth apps.
     */
    id?: string;
    /**
     * The name slug of the target app (see
     * https://pipedream.com/docs/connect/quickstart#find-your-apps-name-slug)
     */
    name_slug: string;
};
/**
 * The types of authentication that Pipedream apps support.
 */
declare enum AppAuthType {
    OAuth = "oauth",
    Keys = "keys",
    None = "none"
}
/**
 * Response object for a Pipedream app's metadata
 */
type App = AppInfo & {
    /**
     * The human-readable name of the app.
     */
    name: string;
    /**
     * A short description of the app.
     */
    description: string;
    /**
     * The authentication type used by the app.
     */
    auth_type: AppAuthType;
    /**
     * The URL to the app's logo.
     */
    img_src: string;
    /**
     * A JSON string representing the custom fields for the app.
     */
    custom_fields_json: string;
    /**
     * Categories associated with the app.
     */
    categories: string[];
    /**
     * A rough directional ordering of app popularity, subject to changes by Pipedream.
     */
    featured_weight: number;
};
/**
 * @deprecated Use `App` instead.
 */
type AppResponse = App;
/**
 * A configuration option for a component's prop.
 */
type PropOption = {
    label: string;
    value: string;
};
type ConfigureComponentContext = Record<string, unknown>;
/**
 * The response received after configuring a component's prop.
 */
type ConfigureComponentResponse = {
    /**
     * The options for the prop that's being configured. This field is applicable
     * when the values don't nicely map to a descriptive string. Useful when the
     * values for each option are meaningless numeric IDs, unless mapped to a
     * human-readable string.
     *
     * @example a branch with ID `21208123` and name `my-repo/foo` in a Gitlab
     * repo
     * ```json
     * {
     *   "label": "my-repo/foo",
     *   "value": 21208123
     * }
     * ```
     */
    options: PropOption[];
    /**
     * The options for the prop that's being configured. This field is applicable
     * when the values themselves are already human-readable strings.
     */
    stringOptions: string[];
    /**
     * A list of errors that occurred during the configuration process.
     */
    errors: string[];
    /**
     * The context object resolved in the options execution (useful for pagination, etc.).
     * See {@link ConfigureComponentOpts.prevContext}.
     */
    context?: ConfigureComponentContext;
};
/**
 * Attributes to use for pagination in API requests.
 */
type RelationOpts = {
    /**
     * The retrieve records starting from a certain cursor.
     */
    after?: string;
    /**
     * To retrieve records up until a certain cursor.
     */
    before?: string;
    /**
     * The maximum number of records to retrieve.
     */
    limit?: number;
};
/**
 * Pagination attributes for API responses.
 */
type ResponsePageInfo = {
    /**
     * The total number of records available.
     */
    total_count: number;
    /**
     * The number of records returned in the current response.
     */
    count: number;
    /**
     * The cursor to retrieve the next page of records.
     */
    start_cursor: string;
    /**
     * The cursor of the last page of records.
     */
    end_cursor: string;
};
/**
 * The response attributes for paginated API responses.
 */
type PaginationResponse = {
    /**
     * The pagination information for the response.
     */
    page_info: ResponsePageInfo;
};
/**
 * @deprecated Use `ConfigureComponentResponse` instead.
 */
type ComponentConfigureResponse = ConfigureComponentResponse;
/**
 * Parameters for the retrieval of apps from the Connect API
 */
type GetAppsOpts = RelationOpts & {
    /**
     * A search query to filter the apps.
     */
    q?: string;
    /**
     * Filter by whether apps have actions in the component registry.
     */
    hasActions?: boolean;
    /**
     * Filter by whether apps have components in the component registry.
     */
    hasComponents?: boolean;
    /**
     * Filter by whether apps have triggers in the component registry.
     */
    hasTriggers?: boolean;
};
/**
 * Parameters for the retrieval of accounts from the Connect API
 */
type GetAccountOpts = RelationOpts & {
    /**
     * The ID or name slug of the app, in case you want to only retrieve the
     * accounts for a specific app.
     */
    app?: string;
    /**
     * The ID of the app (if it's an OAuth app), in case you want to only retrieve
     * the accounts for a specific app.
     */
    oauth_app_id?: string;
    /**
     * Whether to retrieve the account's credentials or not.
     */
    include_credentials?: boolean;
    /**
     * The external user ID associated with the account.
     */
    external_user_id?: string;
};
/**
 * End user account data, returned from the API.
 */
type Account = {
    /**
     * The unique ID of the account.
     */
    id: string;
    /**
     * The name of the account.
     */
    name: string;
    /**
     * The external ID associated with the account.
     */
    external_id: string;
    /**
     * Indicates if the account is healthy. Pipedream will periodically retry
     * token refresh and test requests for unhealthy accounts.
     */
    healthy: boolean;
    /**
     * Indicates if the account is no longer active.
     */
    dead: boolean;
    /**
     * The app associated with the account.
     */
    app: AppResponse;
    /**
     * The date and time the account was created, an ISO 8601 formatted string.
     */
    created_at: string;
    /**
     * The date and time the account was last updated, an ISO 8601 formatted
     * string.
     */
    updated_at: string;
    /**
     * The credentials associated with the account, if the `include_credentials`
     * parameter was set to true in the request.
     */
    credentials?: Record<string, string>;
};
/**
 * The request options for reloading a component's props when dealing with
 * dynamic props.
 */
type ReloadComponentPropsOpts = ExternalUserId & {
    /**
     * The ID of the component you're configuring. This is the key that uniquely
     * identifies the component.
     */
    componentId: string | ComponentId;
    /**
     * The props that have already been configured for the component. This is a
     * JSON-serializable object with the prop names as keys and the configured
     * values as values.
     */
    configuredProps: ConfiguredProps<ConfigurableProps>;
    /**
     * The ID of the last prop reload (or none when reloading the props for the
     * first time).
     */
    dynamicPropsId?: string;
};
type ReloadComponentPropsResponse = {
    /**
     * A list of errors that occurred during the prop reloading process.
     */
    errors: string[];
    /**
     * Dynamic props object containing the dynamic props ID and the dynamic
     * configurable props for the component.
     */
    dynamicProps: {
        id: string;
        configurableProps: ConfigurableProps;
    };
};
/**
 * @deprecated Use `ReloadComponentPropsOpts` instead.
 */
type ComponentReloadPropsOpts = ReloadComponentPropsOpts;
/**
 * The request options for configuring a component's prop.
 */
type ConfigureComponentOpts = ExternalUserId & {
    /**
     * The ID of the component you're configuring. This is the key that uniquely
     * identifies the component.
     */
    componentId: string | ComponentId;
    /**
     * The name of the prop you're configuring.
     */
    propName: string;
    /**
     * The props that have already been configured for the component. This is a
     * JSON-serializable object with the prop names as keys and the configured
     * values as values.
     */
    configuredProps: ConfiguredProps<ConfigurableProps>;
    /**
     * The ID of the last prop reconfiguration (if any).
     */
    dynamicPropsId?: string;
    /**
     * A string with the user input if the prop has the useQuery property set to
     * true. Use with APIs that return items based on a query or search parameter.
     */
    query?: string;
    /**
     * A 0 indexed page number. Use with APIs that accept a
     * numeric page number for pagination.
     */
    page?: number;
    /**
     * The context object from the previous options execution (useful for pagination, etc.).
     * See {@link ConfigureComponentResponse.context}.
     */
    prevContext?: ConfigureComponentContext;
};
/**
 * @deprecated Use `ConfigureComponentOpts` instead.
 */
type ComponentConfigureOpts = ConfigureComponentOpts;
/**
 * The request options for retrieving a list of components.
 */
type GetComponentsOpts = RelationOpts & {
    /**
     * A search query to filter the components.
     */
    q?: string;
    /**
     * The ID or name slug of the app to filter the components.
     */
    app?: string;
    /**
     * The type of component to filter (either "trigger" or "action").
     */
    componentType?: ComponentType;
};
/**
 * @deprecated Use `GetComponentsOpts` instead.
 */
type GetComponentOpts = GetComponentsOpts;
/**
 * An object that identifies a single, unique component in Pipedream.
 */
type ComponentId = {
    /**
     * The key that uniquely identifies the component.
     *
     * @example "gitlab-list-commits"
     * @example "slack-send-message"
     */
    key: string;
};
/**
 * Components can be either triggers or actions.
 */
type ComponentType = "trigger" | "action";
/**
 * Response received after creating a connect token.
 */
type ConnectTokenResponse = {
    /**
     * The generated token.
     */
    token: string;
    /**
     * The expiration time of the token in ISO 8601 format.
     */
    expires_at: string;
    /**
     * The Connect Link URL
     */
    connect_link_url: string;
};
/**
 * The response received when retrieving a list of accounts.
 */
type GetAccountsResponse = PaginationResponse & {
    data: Account[];
};
/**
 * @deprecated Use `GetAccountsResponse` instead.
 */
type AccountsRequestResponse = GetAccountsResponse;
/**
 * The response received when retrieving a list of apps.
 */
type GetAppsResponse = PaginationResponse & {
    data: App[];
};
/**
 * @deprecated Use `GetAppsResponse` instead.
 */
type AppsRequestResponse = GetAppsResponse;
/**
 * The response received when retrieving a specific app.
 */
type GetAppResponse = {
    data: App;
};
/**
 * @deprecated Use `GetAppResponse` instead.
 */
type AppRequestResponse = GetAppResponse;
/**
 * The response received when retrieving a list of components.
 */
type GetComponentsResponse = PaginationResponse & {
    data: V1Component[];
};
/**
 * @deprecated Use `GetComponentsResponse` instead.
 */
type ComponentsRequestResponse = GetComponentsResponse;
/**
 * The response received when retrieving a specific component.
 */
type GetComponentResponse = {
    data: V1Component;
};
/**
 * @deprecated Use `GetComponentResponse` instead.
 */
type ComponentRequestResponse = GetComponentResponse;
/**
 * The request options for running an action.
 */
type RunActionOpts = ExternalUserId & {
    /**
     * The ID of the action you're running. This is the key that uniquely
     * identifies the action.
     */
    actionId: string | ComponentId;
    /**
     * The props that have already been configured for the action. This is a
     * JSON-serializable object with the prop names as keys and the configured
     * values as values.
     */
    configuredProps: ConfiguredProps<ConfigurableProps>;
    /**
     * The ID of the last prop reconfiguration (if any).
     */
    dynamicPropsId?: string;
    /**
     * The ID of the File Stash to sync the action's /tmp directory with. This
     * allows you to persist files across action runs for up to 1 day. If set to
     * `true` or "", a unique stash ID will be generated for you and returned in
     * the response. If not set, the action will not sync its /tmp directory with
     * a File Stash.
     */
    stashId?: string | boolean;
};
/**
 * The response received after running an action. See
 * https://pipedream.com/docs/components/api#returning-data-from-steps for more
 * details.
 */
type RunActionResponse = {
    /**
     * The key-value pairs resulting from calls to `$.export`
     */
    exports: unknown;
    /**
     * Any logs produced during the execution of the action
     */
    os: unknown[];
    /**
     * The value returned by the action
     */
    ret: unknown;
    /**
     * The ID of the File Stash that was used to sync the action's /tmp directory
     */
    stashId?: string;
};
/**
 * The request options for deploying a trigger.
 */
type DeployTriggerOpts = ExternalUserId & {
    /**
     * The ID of the trigger you're deploying. This is the key that uniquely
     * identifies the trigger.
     */
    triggerId: string | ComponentId;
    /**
     * The props that have already been configured for the trigger. This is a
     * JSON-serializable object with the prop names as keys and the configured
     * values as values.
     */
    configuredProps: ConfiguredProps<ConfigurableProps>;
    /**
     * The ID of the last prop reconfiguration (if any).
     */
    dynamicPropsId?: string;
    /**
     * The ID of the workflow that the trigger will use to send the events it
     * generates.
     */
    workflowId?: string;
    /**
     * The webhook URL that the trigger will use to send the events it generates.
     */
    webhookUrl?: string;
};
/**
 * The response received after deploying a trigger.
 */
type DeployTriggerResponse = {
    /**
     * The contents of the deployed trigger.
     */
    data: V1DeployedComponent;
};
/**
 * The request options for deleting a deployed trigger owned by a particular
 * user.
 */
type DeleteTriggerOpts = {
    /**
     * The ID of the trigger you're deleting (`dc_xxxxxxx` for example ).
     */
    id: string;
    /**
     * The end user ID, for whom you deployed the trigger.
     */
    externalUserId: string;
    /**
     * When explicitly set, the API will ignore any errors that occur during the
     * deactivation hook of the trigger, effectively forcing the deletion of the
     * trigger.
     */
    ignoreHookErrors?: boolean;
};
/**
 * The request options for retrieving a deployed trigger owned by a particular
 * user.
 */
type GetTriggerOpts = {
    /**
     * The ID of the trigger you're retrieving.
     */
    id: string;
    /**
     * Your end user ID, for whom you deployed the trigger.
     */
    externalUserId: string;
};
/**
 * The response received after retrieving a deployed trigger.
 */
type GetTriggerResponse = {
    /**
     * The contents of the deployed trigger.
     */
    data: V1DeployedComponent;
};
/**
 * The request options for retrieving the events emitted by a deployed trigger.
 */
type GetTriggerEventsOpts = GetTriggerOpts & {
    /**
     * The number of events to retrieve (defaults to 20 if not provided).
     */
    limit?: number;
};
/**
 * The response from retrieving the events emitted by a deployed trigger.
 */
type GetTriggerEventsResponse = {
    /**
     * The list of events emitted by the trigger.
     */
    data: V1EmittedEvent[];
};
/**
 * The request options for retrieving the workflows that listen to events
 * emitted by a specific trigger.
 */
type GetTriggerWorkflowsOpts = GetTriggerOpts;
/**
 * The response from retrieving the workflows that listen to events emitted by a
 * specific trigger.
 */
type GetTriggerWorkflowsResponse = {
    /**
     * The list of workflow IDs that listen to events emitted by the trigger.
     */
    workflow_ids: string[];
};
/**
 * The request options for updating the workflows that listen to events emitted
 * by a specific trigger.
 */
type UpdateTriggerWorkflowsOpts = GetTriggerOpts & {
    /**
     * The workflow IDs that should to events emitted by the trigger.
     */
    workflowIds: string[];
};
/**
 * The request options for retrieving the webhooks that listen to events
 * emitted by a specific trigger.
 */
type GetTriggerWebhooksOpts = GetTriggerOpts;
/**
 * The response from retrieving the webhooks that listen to events emitted by a
 * specific trigger.
 */
type GetTriggerWebhooksResponse = {
    /**
     * The list of webhook URLs that listen to events emitted by the trigger.
     */
    webhook_urls: string[];
};
/**
 * The request options for updating the webhooks that listen to events emitted
 * by a specific trigger.
 */
type UpdateTriggerWebhooksOpts = GetTriggerOpts & {
    /**
     * The webhook URLs that should to events emitted by the trigger.
     */
    webhookUrls: string[];
};
/**
 * The request options for retrieving a list of deployed triggers for a
 * particular user.
 */
type GetTriggersOpts = RelationOpts & {
    /**
     * Your end user ID, for whom you deployed the trigger.
     */
    externalUserId: string;
};
/**
 * The response received after retrieving a list of deployed triggers.
 */
type GetTriggersResponse = PaginationResponse & {
    /**
     * The list of deployed triggers.
     */
    data: V1DeployedComponent[];
};
/**
 * The request options for updating a trigger.
 */
type UpdateTriggerOpts = {
    /**
     * The ID of the trigger you're updating.
     */
    id: string;
    /**
     * Your end user ID, for whom you deployed the trigger.
     */
    externalUserId: string;
    /**
     * The state to which the trigger should be updated.
     */
    active?: boolean;
    /**
     * The props that have already been configured for the trigger. This is a
     * JSON-serializable object with the prop names as keys and the configured
     * values as values.
     */
    configuredProps?: ConfiguredProps<ConfigurableProps>;
    /**
     * The new name of the trigger.
     */
    name?: string;
};
/**
 * Different ways in which customers can authorize requests to HTTP endpoints
 */
declare enum HTTPAuthType {
    None = "none",
    StaticBearer = "static_bearer_token",
    OAuth = "oauth"
}
/**
 * Error response returned by the API in case of an error.
 */
type ErrorResponse = {
    /**
     * The error message returned by the API.
     */
    error: string;
};
/**
 * A generic API response that can either be a success or an error.
 */
type ConnectAPIResponse<T> = T | ErrorResponse;
/**
 * Options for making a request to the Pipedream API.
 */
interface RequestOptions extends Omit<RequestInit, "headers" | "body"> {
    /**
     * Query parameters to include in the request URL.
     */
    params?: Record<string, string | boolean | number | null>;
    /**
     * Headers to include in the request.
     */
    headers?: Record<string, string>;
    /**
     * The URL to make the request to.
     */
    baseURL?: string;
    /**
     * The body of the request.
     */
    body?: Record<string, unknown> | string | FormData | URLSearchParams | null;
}
interface AsyncRequestOptions extends RequestOptions {
    body: {
        async_handle: string;
    } & Required<RequestOptions["body"]>;
}
declare function DEBUG(...args: any[]): void;
/**
 * A client for interacting with the Pipedream Connect API on the server-side.
 */
declare abstract class BaseClient {
    version: string;
    protected apiHost: string;
    protected readonly baseApiUrl: string;
    protected environment: string;
    protected projectId?: string;
    protected readonly workflowDomain: string;
    /**
     * Constructs a new BackendClient instance.
     *
     * @param opts - The options for configuring the server client.
     */
    constructor(opts: ClientOpts);
    /**
     * Retrieves the current environment the client is configured to use.
     * @returns {string} The current environment.
     */
    getEnvironment(): string;
    /**
     * Makes an HTTP request
     *
     * @template T - The expected response type.
     * @param path - The API endpoint path.
     * @param opts - The options for the request.
     * @returns A promise resolving to the API response.
     * @throws Will throw an error if the response status is not OK.
     */
    makeRequest<T>(path: string, opts?: RequestOptions): Promise<T>;
    protected abstract authHeaders(): string | Promise<string>;
    /**
     * Makes a request to the Pipedream API with appropriate authorization.
     *
     * @template T - The expected response type.
     * @param path - The API endpoint path.
     * @param opts - The options for the request.
     * @returns A promise resolving to the API response.
     * @throws Will throw an error if the response status is not OK.
     */
    makeAuthorizedRequest<T>(path: string, opts?: RequestOptions): Promise<T>;
    /**
     * Makes a request to the Connect API using Connect authorization.
     *
     * @template T - The expected response type.
     * @param path - The API endpoint path.
     * @param opts - The options for the request.
     * @returns A promise resolving to the API response.
     */
    protected makeConnectRequest<T>(path: string, opts?: RequestOptions): Promise<T>;
    /**
     * Retrieves the list of accounts associated with the project.
     *
     * @param params - The query parameters for retrieving accounts.
     * @returns A promise resolving to a list of accounts.
     *
     * @example
     * ```typescript
     * const accounts = await client.getAccounts({ include_credentials: true });
     * console.log(accounts);
     * ```
     */
    getAccounts(params?: GetAccountOpts): Promise<GetAccountsResponse>;
    /**
     * Retrieves the list of apps available in Pipedream.
     *
     * @param opts - The options for retrieving apps.
     * @returns A promise resolving to a list of apps.
     *
     * @example
     * ```typescript
     * const apps = await client.getApps({ q: "slack" });
     * console.log(apps);
     * ```
     */
    getApps(opts?: GetAppsOpts): Promise<GetAppsResponse>;
    /**
     * @deprecated Use `getApps` instead.
     */
    apps(opts?: GetAppsOpts): Promise<GetAppsResponse>;
    /**
     * Retrieves the metadata for a specific app.
     *
     * @param idOrNameSlug - The ID or name slug of the app.
     * @returns A promise resolving to the app metadata.
     *
     * @example
     * ```typescript
     * const app = await client.getApp("slack");
     * console.log(app);
     * ```
     */
    getApp(idOrNameSlug: string): Promise<GetAppResponse>;
    /**
     * @deprecated Use `getApp` instead.
     */
    app(idOrNameSlug: string): Promise<GetAppResponse>;
    /**
     * Retrieves the list of components available in Pipedream.
     *
     * @param opts - The options for retrieving components.
     * @returns A promise resolving to a list of components.
     *
     * @example
     * ```typescript
     * const components = await client.getComponents({ q: "slack" });
     * console.log(components);
     * ```
     */
    getComponents(opts?: GetComponentsOpts): Promise<GetComponentsResponse>;
    /**
     * @deprecated Use `getComponents` instead.
     */
    components(opts?: GetComponentOpts): Promise<GetComponentsResponse>;
    /**
     * Retrieves the metadata for a specific component.
     *
     * @param id - The identifier of the component.
     * @returns A promise resolving to the component metadata.
     *
     * @example
     * ```typescript
     * const component = await client.getComponent("slack-send-message");
     * console.log(component);
     * ```
     */
    getComponent(id: ComponentId): Promise<GetComponentResponse>;
    /**
     * @deprecated Use `getComponent` instead.
     */
    component({ key }: {
        key: string;
    }): Promise<GetComponentResponse>;
    /**
     * Configure the next component's prop, based on the current component's
     * configuration.
     *
     * @param opts - The options for configuring the component.
     * @returns A promise resolving to the response from the configuration.
     *
     * @example
     * ```typescript
     * const { options } = await client.configureComponent({
     *  externalUserId: "jverce",
     *  componentId: {
     *    key: "slack-send-message",
     *  },
     *  propName: "channel",
     *  configuredProps: {
     *    slack: {
      *     authProvisionId: "apn_z8hD1b4",
      *   },
     *  },
     * });
     * console.log(options);
     */
    configureComponent(opts: ConfigureComponentOpts): Promise<ConfigureComponentResponse>;
    /**
     * @deprecated Use `configureComponent` instead.
     */
    componentConfigure(opts: ComponentConfigureOpts): Promise<ConfigureComponentResponse>;
    /**
     * Reload the component prop's based on the current component's configuration.
     * This applies to dynamic props (see the docs for more info:
     * https://pipedream.com/docs/components/api#dynamic-props).
     *
     * @param opts - The options for reloading the component's props.
     * @returns A promise resolving to the response from the reload.
     *
     * @example
     * ```typescript
     * const { dynamicProps } = await client.reloadComponentProps({
     *  externalUserId: "jverce",
     *  componentId: {
     *    key: "slack-send-message",
     *  },
     *  configuredProps: {
     *    slack: {
     *      authProvisionId: "apn_z8hD1b4",
     *    },
     *  },
     * });
     *
     * const { configurableProps, id: dynamicPropsId } = dynamicProps;
     * // Use `dynamicPropsId` to configure the next prop
     * // Use `configurableProps` to display the new set of props to the user
     */
    reloadComponentProps(opts: ReloadComponentPropsOpts): Promise<ReloadComponentPropsResponse>;
    /**
     * @deprecated Use `reloadComponentProps` instead.
     */
    componentReloadProps(opts: ComponentReloadPropsOpts): Promise<ReloadComponentPropsResponse>;
    /**
     * Invoke an action component for a Pipedream Connect user in a project
     *
     * @param opts - The options for running the action.
     * @returns A promise resolving to the response from the action's execution.
     *
     * @example
     * ```typescript
     * const response = await client.runAction({
     *   externalUserId: "jverce",
     *   actionId: {
     *     key: "gitlab-list-commits",
     *   },
     *   configuredProps: {
     *     gitlab: {
     *       authProvisionId: "apn_z8hD1b4"
     *     },
     *     projectId: 21208123,
     *     refName: "10-0-stable-ee",
     *   },
     * });
     * console.log(response);
     * ```
     */
    runAction(opts: RunActionOpts): Promise<RunActionResponse>;
    /**
     * @deprecated Use `runAction` instead.
     */
    actionRun(opts: RunActionOpts): Promise<RunActionResponse>;
    /**
     * Deploy a trigger component for a Pipedream Connect user in a project
     *
     * @param opts - The options for deploying the trigger.
     * @returns A promise resolving to the response from the trigger's deployment.
     *
     * @example
     * ```typescript
     * const response = await client.deployTrigger({
     *   externalUserId: "jverce",
     *   triggerId: {
     *     key: "gitlab-new-issue",
     *   },
     *   configuredProps: {
     *     gitlab: {
     *       authProvisionId: "apn_z8hD1b4",
     *     },
     *     projectId: 21208123,
     *   },
     *   webhookUrl: "https://dest.mydomain.com",
     * });
     * console.log(response);
     */
    deployTrigger(opts: DeployTriggerOpts): Promise<DeployTriggerResponse>;
    /**
     * @deprecated Use `deployTrigger` instead.
     */
    triggerDeploy(opts: DeployTriggerOpts): Promise<DeployTriggerResponse>;
    /**
     * Deletes a specific trigger.
     *
     * @param opts - The options for deleting the trigger.
     * @returns No content
     */
    deleteTrigger(opts: DeleteTriggerOpts): Promise<void>;
    /**
     * Retrieves the metadata for a specific trigger.
     *
     * @param opts - The options for retrieving the trigger.
     * @returns A promise resolving to the trigger metadata.
     */
    getTrigger(opts: GetTriggerOpts): Promise<GetTriggerResponse>;
    /**
     * Retrieves the metadata for all deployed triggers
     *
     * @param opts - The options for retrieving the triggers.
     * @returns A promise resolving to a list of the trigger metadata.
     */
    getTriggers(opts: GetTriggersOpts): Promise<GetTriggersResponse>;
    /**
     * Updates a specific trigger.
     *
     * @param opts - The options for updating the trigger.
     * @returns A promise resolving to the trigger metadata.
     */
    updateTrigger(opts: UpdateTriggerOpts): Promise<GetTriggerResponse>;
    /**
     * Retrieves the last events emitted by a specific trigger.
     *
     * @param opts - The options for retrieving the trigger events.
     * @returns A promise resolving to a list of emitted events.
     */
    getTriggerEvents(opts: GetTriggerEventsOpts): Promise<GetTriggerEventsResponse>;
    /**
     * Retrieves the list of workflows to which the trigger emits events.
     *
     * @param opts - The options for retrieving the listening workflows.
     * @returns A promise resolving to a list of workflows.
     */
    getTriggerWorkflows(opts: GetTriggerWorkflowsOpts): Promise<GetTriggerWorkflowsResponse>;
    /**
     * Updates the list of workflows to which the trigger will emit events.
     *
     * @param opts - The options for updating the listening workflows.
     * @throws If `workflowIds` is not an array.
     * @returns A promise resolving to a list of workflows.
     */
    updateTriggerWorkflows(opts: UpdateTriggerWorkflowsOpts): Promise<GetTriggerWorkflowsResponse>;
    /**
     * Retrieves the list of webhooks to which the trigger emits events.
     *
     * @param opts - The options for retrieving the listening webhooks.
     * @returns A promise resolving to a list of webhooks.
     */
    getTriggerWebhooks(opts: GetTriggerWebhooksOpts): Promise<GetTriggerWebhooksResponse>;
    /**
     * Updates the list of webhooks to which the trigger will emit events.
     *
     * @param opts - The options for updating the listening webhooks.
     * @throws If `webhookUrls` is not an array.
     * @returns A promise resolving to a list of webhooks.
     */
    updateTriggerWebhooks(opts: UpdateTriggerWebhooksOpts): Promise<GetTriggerWebhooksResponse>;
    /**
     * Builds a full workflow URL based on the input.
     *
     * @param input - Either a full URL (with or without protocol) or just an
     * endpoint ID.
     * @returns The fully constructed URL.
     * @throws If the input is a malformed URL, throws an error with a clear
     * message.
     *
     * @example
     * ```typescript
     * // Full URL input
     * this.buildWorkflowUrl("https://en123.m.pipedream.net");
     * // Returns: "https://en123.m.pipedream.net"
     * ```
     *
     * @example
     * ```typescript
     * // Partial URL (without protocol)
     * this.buildWorkflowUrl("en123.m.pipedream.net");
     * // Returns: "https://en123.m.pipedream.net"
     * ```
     *
     * @example
     * ```typescript
     * // ID only input
     * this.buildWorkflowUrl("en123");
     * // Returns: "https://en123.yourdomain.com" (where `yourdomain.com` is set in `workflowDomain`)
     * ```
     */
    private buildWorkflowUrl;
    /**
     * Invokes a workflow using the URL of its HTTP interface(s), by sending an
     *
     * @param urlOrEndpoint - The URL of the workflow's HTTP interface, or the ID of the endpoint
     * @param opts - The options for the request.
     * @param opts.body - The body of the request. It must be a JSON-serializable
     * value (e.g. an object, null, a string, etc.).
     * @param opts.headers - The headers to include in the request. Note that the
     * Authorization header will always be set with an OAuth access token
     * retrieved by the client.
     * @param authType - The type of authorization to use for the request.
     * @returns A promise resolving to the response from the workflow.
     *
     * @example
     * ```typescript
     * const response: JSON = await client.invokeWorkflow(
     *   "https://en-your-endpoint.m.pipedream.net",
     *   {
     *     body: {
     *       foo: 123,
     *       bar: "abc",
     *       baz: null,
     *     },
     *     headers: {
     *       "Accept": "application/json",
     *     },
     *   },
     *   "oauth",
     * );
     * console.log(response);
     * ```
     */
    invokeWorkflow(urlOrEndpoint: string, opts?: RequestOptions, authType?: HTTPAuthType): Promise<unknown>;
    /**
     * Invokes a workflow for a Pipedream Connect user in a project
     *
     * @param url - The URL of the workflow's HTTP interface.
     * @param externalUserId â€” Your end user ID, for whom you're invoking the
     * workflow.
     * @param opts - The options for the request.
     * @param opts.body - The body of the request. It must be a JSON-serializable
     * value (e.g. an object, null, a string, etc.).
     * @param opts.headers - The headers to include in the request. Note that the
     * Authorization header will always be set with an OAuth access token
     * retrieved by the client.
     * @returns A promise resolving to the response from the workflow.
     *
     * @example
     * ```typescript
     * const response = await client.invokeWorkflowForExternalUser(
     *   "https://your-workflow-url.m.pipedream.net",
     *   "your-external-user-id",
     *   {
     *     body: {
     *       foo: 123,
     *       bar: "abc",
     *       baz: null,
     *     },
     *     headers: {
     *       "Accept": "application/json",
     *     },
     *   },
     * );
     * console.log(response);
     * ```
     */
    invokeWorkflowForExternalUser(url: string, externalUserId: string, opts?: RequestOptions): Promise<unknown>;
    private addRelationOpts;
}

/**
 * Options for creating a browser-side client. This is used to configure the
 * BrowserClient instance.
 */
type CreateBrowserClientOpts = {
    /**
     * @deprecated environment is set on the server when generating the client token
     */
    environment?: string;
    /**
     * The frontend host URL. Used by Pipedream employees only. Defaults to
     * "pipedream.com" if not provided.
     */
    frontendHost?: string;
    /**
     * The API host URL. Used by Pipedream employees. Defaults to
     * "api.pipedream.com" if not provided.
     */
    apiHost?: string;
    /**
     * Will be called whenever we need a new token.
     *
     * The callback function should return the response from
     * `serverClient.createConnectToken`.
     */
    tokenCallback?: TokenCallback;
    /**
     * An external user ID associated with the token.
     */
    externalUserId?: string;
};
type TokenCallback = (opts: {
    externalUserId: string;
}) => Promise<ConnectTokenResponse>;
/**
 * The name slug for an app, a unique, human-readable identifier like "github"
 * or "google_sheets". Find this in the Authentication section for any app's
 * page at https://pipedream.com/apps. For more information about name slugs,
 * see https://pipedream.com/docs/connect/quickstart#find-your-apps-name-slug.
 */
type AppNameSlug = string;
/**
 * The result of a successful connection.
 */
type ConnectResult = {
    /**
     * The unique identifier of the connected account.
     */
    id: string;
};
/**
 * The status when the Connect dialog is closed.
 */
type ConnectStatus = {
    /**
     * Whether the connection was successful (account was connected).
     */
    successful: boolean;
    /**
     * Whether the connection process was completed (vs user closing early).
     */
    completed: boolean;
};
/**
 * Custom error class for handling connection errors.
 */
declare class ConnectError extends Error {
}
/**
 * Options for starting the connection process.
 */
type StartConnectOpts = {
    /**
     * The token used for authenticating the connection.
     *
     * Optional if client already initialized with token
     */
    token?: string;
    /**
     * The app to connect to, either as an ID or an object containing the ID.
     */
    app: AppNameSlug;
    /**
     * The OAuth app ID to connect to.
     */
    oauthAppId?: string;
    /**
     * Callback function to be called upon successful connection.
     *
     * @param res - The result of the connection.
     */
    onSuccess?: (res: ConnectResult) => void;
    /**
     * Callback function to be called if an error occurs during the connection.
     *
     * @param err - The error that occurred during the connection.
     */
    onError?: (err: ConnectError) => void;
    /**
     * Callback function to be called when the Connect iFrame is closed.
     *
     * @param status - The status of the connection when closed.
     */
    onClose?: (status: ConnectStatus) => void;
};
/**
 * Creates a new instance of `BrowserClient` with the provided options.
 *
 * @example
 * ```typescript
    const client = createFrontendClient({
      tokenCallback,
      externalUserId,
    });
 * ```
 * @param opts - The options for creating the browser client.
 * @returns A new instance of `BrowserClient`.
 */
declare function createFrontendClient(opts?: CreateBrowserClientOpts): BrowserClient;
/**
 * A client for interacting with the Pipedream Connect API from the browser.
 */
declare class BrowserClient extends BaseClient {
    private baseURL;
    private iframeURL;
    private iframe?;
    private iframeId;
    private tokenCallback?;
    private _token?;
    private _tokenExpiresAt?;
    private _tokenRequest?;
    externalUserId?: string;
    /**
     * Constructs a new `BrowserClient` instance.
     *
     * @param opts - The options for configuring the browser client.
     */
    constructor(opts: CreateBrowserClientOpts);
    private token;
    private refreshToken;
    /**
     * Retrieves the raw token string.
     *
     * @return {string} The raw token value.
     */
    rawToken(): string | undefined;
    /**
     * Initiates the process of connecting an account.
     *
     * @param opts - The options for starting the connection process.
     *
     * @example
     * ```typescript
     * client.connectAccount({
     *   token: "your-token",
     *   app: "your-app-id",
     *   onSuccess: (res) => {
     *     console.log("Connected account ID:", res.id);
     *   },
     *   onError: (err) => {
     *     console.error("Connection error:", err);
     *   },
     *   onClose: (status) => {
     *     if (!status.successful) {
     *       console.log("User closed without connecting");
     *     }
     *   },
     * });
     * ```
     */
    connectAccount(opts: StartConnectOpts): Promise<void>;
    /**
     * Cleans up the iframe and message event listener after the connection
     * process is complete.
     *
     * @param onMessage - The message event handler to remove.
     */
    private cleanup;
    /**
     * Creates an iframe for the connection process and appends it to the document
     * body.
     *
     * @param opts - The options for starting the connection process.
     *
     * @throws {ConnectError} If the app option is not a string.
     */
    private createIframe;
    protected authHeaders(): Promise<string>;
    getAccounts(params?: Omit<GetAccountOpts, "external_user_id">): Promise<AccountsRequestResponse>;
}

export { type Account, type AccountsRequestResponse, type App, AppAuthType, type AppInfo, type AppRequestResponse, type AppResponse, type AppsRequestResponse, type AsyncRequestOptions, BaseClient, BrowserClient, type ClientOpts, type ComponentConfigureOpts, type ComponentConfigureResponse, type ComponentId, type ComponentReloadPropsOpts, type ComponentRequestResponse, type ComponentType, type ComponentsRequestResponse, type ConfigurableProp, type ConfigurablePropAirtableBaseId, type ConfigurablePropAirtableFieldId, type ConfigurablePropAirtableTableId, type ConfigurablePropAirtableViewId, type ConfigurablePropAlert, type ConfigurablePropAny, type ConfigurablePropApp, type ConfigurablePropApphook, type ConfigurablePropBoolean, type ConfigurablePropDb, type ConfigurablePropDiscordChannel, type ConfigurablePropDiscordChannelArray, type ConfigurablePropHttp, type ConfigurablePropInteger, type ConfigurablePropIntegerArray, type ConfigurablePropObject, type ConfigurablePropSql, type ConfigurablePropString, type ConfigurablePropStringArray, type ConfigurablePropTimer, type ConfigurableProps, type ConfigureComponentOpts, type ConfigureComponentResponse, type ConfiguredProps, type ConnectAPIResponse, type ConnectTokenResponse, DEBUG, type DeleteTriggerOpts, type DeployTriggerOpts, type DeployTriggerResponse, type ErrorResponse, type GetAccountOpts, type GetAccountsResponse, type GetAppResponse, type GetAppsOpts, type GetAppsResponse, type GetComponentOpts, type GetComponentResponse, type GetComponentsOpts, type GetComponentsResponse, type GetTriggerEventsOpts, type GetTriggerEventsResponse, type GetTriggerOpts, type GetTriggerResponse, type GetTriggerWebhooksOpts, type GetTriggerWebhooksResponse, type GetTriggerWorkflowsOpts, type GetTriggerWorkflowsResponse, type GetTriggersOpts, type GetTriggersResponse, HTTPAuthType, type PaginationResponse, type PropOption, type PropValue, type RelationOpts, type ReloadComponentPropsOpts, type ReloadComponentPropsResponse, type RequestOptions, type ResponsePageInfo, type RunActionOpts, type RunActionResponse, type TimerCron, type TimerInterval, type TokenCallback, type UpdateTriggerOpts, type UpdateTriggerWebhooksOpts, type UpdateTriggerWorkflowsOpts, type V1Component, type V1DeployedComponent, type V1EmittedEvent, createFrontendClient };

{"version":3,"sources":["../src/server/index.ts","../src/version.ts","../src/shared/index.ts"],"sourcesContent":["// This code is meant to be run server-side, where you can securely store your\n// Pipedream project's public and secret keys and access customer credentials.\n// See the browser/ directory for the browser client.\n\nimport * as oauth from \"oauth4webapi\";\nimport {\n  Account, BaseClient, type AppInfo, type ConnectTokenResponse, type RequestOptions,\n} from \"../shared/index.js\";\nexport * from \"../shared/index.js\";\n\n/**\n * OAuth credentials for your Pipedream account, containing client ID and\n * secret.\n */\nexport type OAuthCredentials = {\n  clientId: string;\n  clientSecret: string;\n};\n\n/**\n * The environment in which the server client is running.\n */\nexport type ProjectEnvironment = \"development\" | \"production\";\n\n/**\n * Options for creating a server-side client.\n * This is used to configure the ServerClient instance.\n */\nexport type BackendClientOpts = {\n  /**\n   * The environment in which the server client is running (e.g., \"production\",\n   * \"development\").\n   */\n  environment?: ProjectEnvironment;\n\n  /**\n   * The credentials to use for authentication against the Pipedream API.\n   */\n  credentials: OAuthCredentials | {\n    accessToken: string;\n  };\n\n  /**\n   * The base project ID tied to relevant API requests\n   */\n  projectId: string;\n\n  /**\n   * The API host URL. Used by Pipedream employees. Defaults to\n   * \"api.pipedream.com\" if not provided.\n   */\n  apiHost?: string;\n\n  /**\n   * Base domain for workflows. Used for custom domains:\n   * https://pipedream.com/docs/workflows/domains\n   */\n  workflowDomain?: string;\n};\n\n/**\n * Options for creating a Connect token.\n */\nexport type ConnectTokenCreateOpts = {\n  /**\n   * The ID of the user in your system.\n   */\n  external_user_id: string;\n\n  /**\n   * The optional url to redirect the user to upon successful connection.\n   */\n  success_redirect_uri?: string;\n\n  /**\n   * The optional url to redirect the user to upon failed connection.\n   */\n  error_redirect_uri?: string;\n\n  /**\n   * An optional webhook uri that Pipedream can invoke on success or failure of\n   * connection requests.\n   */\n  webhook_uri?: string;\n\n  /**\n   * Specify which origins can use the token to call the Pipedream API.\n   */\n  allowed_origins?: string[];\n};\n\n/**\n * Response received after requesting a project's info.\n */\nexport type ProjectInfoResponse = {\n  /**\n   * An array of apps linked to the project.\n   */\n  apps: AppInfo[];\n};\n\n/**\n * Parameters for the retrieval of an account from the Connect API\n */\nexport type GetAccountByIdOpts = {\n  /**\n   * Whether to retrieve the account's credentials or not.\n   */\n  include_credentials?: boolean;\n};\n\n/**\n * Options used to determine the external user and account to be used in Connect Proxy API\n */\nexport type ProxyApiOpts  = {\n  /**\n   * Search parameters to be added to the proxy request.  external_user_id and account_id are required.\n   */\n  searchParams: Record<string, string>;\n};\n\n/**\n * fetch-like options for the Target of the Connect Proxy Api Request\n */\nexport type ProxyTargetApiOpts = {\n  /**\n   * http method for the request\n   */\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n  /**\n   * http headers for the request\n   */\n  headers?: Record<string, string>;\n  /**\n   * http body for the request\n   */\n  body?: string;\n};\n\n/**\n * object that contains the url and options for the target of the Connect Proxy Api Request\n */\nexport type ProxyTargetApiRequest = {\n  /**\n   * URL for the target of the request.  Search parameters must be included here.\n   */\n  url: string;\n  /**\n   * fetch-like options for the target of the Connect Proxy Request\n   */\n  options: ProxyTargetApiOpts;\n};\n\n/**\n * The parsed response body from a proxied API request.\n *\n * If the response has a Content-Type of application/json, the body will be parsed\n * and returned as an object. Otherwise the type will be a string.\n */\nexport type ProxyResponse = Record<string, unknown> | string;\n\n/**\n * Creates a new instance of BackendClient with the provided options.\n *\n * @example\n *\n * ```typescript\n      const serverClient = createBackendClient({\n        environment: \"development\",\n        projectId: \"<project id>\",\n        credentials: {\n          clientId: \"<client id>\",\n          clientSecret: \"<client secret>\",\n        },\n      })\n * ```\n *\n * @param opts - The options for creating the server client.\n * @returns A new instance of ServerClient.\n */\nexport function createBackendClient(opts: BackendClientOpts) {\n  return new BackendClient(opts);\n}\n\n/**\n * A client for interacting with the Pipedream Connect API on the server-side.\n */\nexport class BackendClient extends BaseClient {\n  private oauthClient: {\n    client: oauth.Client\n    clientAuth: oauth.ClientAuth\n    as: oauth.AuthorizationServer\n  } | undefined;\n  private oauthAccessToken?: {\n    token: string\n    expiresAt: number\n  };\n  protected override projectId: string = \"\";\n  private staticAccessToken?: string;\n\n  /**\n   * Constructs a new ServerClient instance.\n   *\n   * @param opts - The options for configuring the server client.\n   * @param oauthClient - An optional OAuth client to use for authentication in tests\n   */\n  constructor(opts: BackendClientOpts) {\n    super(opts);\n\n    this.ensureValidEnvironment(opts.environment);\n    this.projectId = opts.projectId;\n    if (\"accessToken\" in opts.credentials) {\n      this.staticAccessToken = opts.credentials.accessToken;\n    } else {\n      this.oauthClient = this.newOauthClient(opts.credentials, this.apiHost);\n    }\n  }\n\n  private ensureValidEnvironment(environment?: string) {\n    if (!environment || ![\n      \"development\",\n      \"production\",\n    ].includes(environment)) {\n      throw new Error(\n        \"Project environment is required. Supported environments are development and production.\",\n      );\n    }\n  }\n\n  private newOauthClient(\n    {\n      clientId, clientSecret,\n    }: OAuthCredentials,\n    tokenHost: string,\n  ) {\n    if (!clientId || !clientSecret) {\n      throw new Error(\"OAuth client ID and secret are required\");\n    }\n    const client: oauth.Client = {\n      client_id: clientId,\n    }\n    const clientAuth = oauth.ClientSecretPost(clientSecret)\n    const as: oauth.AuthorizationServer = {\n      issuer: tokenHost,\n      token_endpoint: `https://${tokenHost}/v1/oauth/token`,\n    }\n    return {\n      client,\n      clientAuth,\n      as,\n    }\n  }\n\n  /**\n   * Returns the raw access token string or a promise resolving to it.\n   * This can be used when you need the token directly without Authorization header formatting.\n   *\n   * @returns A string or promise resolving to the access token.\n   */\n  public rawAccessToken(): string | Promise<string> {\n    if (this.staticAccessToken) {\n      return this.staticAccessToken;\n    }\n    return this.ensureValidOauthAccessToken();\n  }\n\n  protected authHeaders(): string | Promise<string> {\n    if (this.staticAccessToken) {\n      return `Bearer ${this.staticAccessToken}`;\n    }\n    return this.oauthAuthorizationHeader();\n  }\n\n  private async ensureValidOauthAccessToken(): Promise<string> {\n    if (!this.oauthClient) {\n      throw new Error(\"OAuth client not configured\")\n    }\n    const {\n      client,\n      clientAuth,\n      as,\n    } = this.oauthClient\n\n    let attempts = 0;\n    const maxAttempts = 2;\n\n    while (!this.oauthAccessToken || this.oauthAccessToken.expiresAt - Date.now() < 1000) {\n      if (attempts > maxAttempts) {\n        throw new Error(\"ran out of attempts trying to retrieve oauth access token\");\n      }\n      if (attempts > 0) {\n        // Wait for a short duration before retrying to avoid rapid retries\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n\n      const parameters = new URLSearchParams();\n      try {\n        const response = await oauth.clientCredentialsGrantRequest(as, client, clientAuth, parameters);\n        const oauthTokenResponse = await oauth.processClientCredentialsResponse(as, client, response);\n        this.oauthAccessToken = {\n          token: oauthTokenResponse.access_token,\n          expiresAt: Date.now() + (oauthTokenResponse.expires_in || 0) * 1000,\n        };\n      } catch {\n        // pass\n      }\n\n      attempts++;\n    }\n\n    return this.oauthAccessToken.token;\n  }\n\n  private async oauthAuthorizationHeader(): Promise<string> {\n    const accessToken = await this.ensureValidOauthAccessToken();\n\n    return `Bearer ${accessToken}`;\n  }\n\n  /**\n   * Creates a new Pipedream Connect token. See\n   * https://pipedream.com/docs/connect/quickstart#connect-to-the-pipedream-api-from-your-server-and-create-a-token\n   *\n   * @param opts - The options for creating the connect token.\n   * @returns A promise resolving to the connect token response.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tokenResponse = await client.connectTokenCreate({\n   *   external_user_id: \"external-user-id\", });\n   * console.log(tokenResponse.token);\n   * ```\n   */\n  public createConnectToken(\n    opts: ConnectTokenCreateOpts,\n  ): Promise<ConnectTokenResponse> {\n    const body = {\n      ...opts,\n      external_id: opts.external_user_id,\n    };\n    return this.makeConnectRequest(\"/tokens\", {\n      method: \"POST\",\n      body,\n    });\n  }\n\n  /**\n   * Retrieves a specific account by ID.\n   *\n   * @param accountId - The ID of the account to retrieve.\n   * @param params - Additional options for the request.\n   * @returns A promise resolving to the account.\n   *\n   * @example\n   * ```typescript\n   * const account = await client.getAccountById(\"account-id\");\n   * console.log(account);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * const account = await client.getAccountById(\"account-id\", {\n   *   include_credentials: true,\n   * });\n   * console.log(account);\n   * ```\n   */\n  public getAccountById(\n    accountId: string,\n    params: GetAccountByIdOpts = {},\n  ): Promise<Account> {\n    return this.makeConnectRequest(`/accounts/${accountId}`, {\n      method: \"GET\",\n      params,\n    });\n  }\n\n  /**\n   * Deletes a specific account by ID.\n   *\n   * @param accountId - The ID of the account to delete.\n   * @returns A promise resolving when the account is deleted.\n   *\n   * @example\n   * ```typescript\n   * await client.deleteAccount(\"account-id\");\n   * console.log(\"Account deleted\");\n   * ```\n   */\n  public deleteAccount(accountId: string): Promise<void> {\n    return this.makeConnectRequest(`/accounts/${accountId}`, {\n      method: \"DELETE\",\n    });\n  }\n\n  /**\n   * Deletes all accounts associated with a specific app.\n   *\n   * @param appId - The ID of the app.\n   * @returns A promise resolving when all accounts are deleted.\n   *\n   * @example\n   * ```typescript\n   * await client.deleteAccountsByApp(\"app-id\");\n   * console.log(\"All accounts deleted\");\n   * ```\n   */\n  public deleteAccountsByApp(appId: string): Promise<void> {\n    return this.makeConnectRequest(`/accounts/app/${appId}`, {\n      method: \"DELETE\",\n    });\n  }\n\n  /**\n   * Deletes all accounts associated with a specific external ID.\n   *\n   * @param externalId - The external ID associated with the accounts.\n   * @returns A promise resolving when all accounts are deleted.\n   *\n   * @example\n   * ```typescript\n   * await client.deleteExternalUser(\"external-id\");\n   * console.log(\"All accounts deleted\");\n   * ```\n   */\n  public deleteExternalUser(externalId: string): Promise<void> {\n    return this.makeConnectRequest(`/users/${externalId}`, {\n      method: \"DELETE\",\n    });\n  }\n\n  /**\n   * Retrieves the project's information, such as the list of apps linked to it.\n   *\n   * @returns A promise resolving to the project info response.\n   *\n   * @example\n   * ```typescript\n   * const projectInfo = await client.getProjectInfo();\n   * console.log(projectInfo);\n   * ```\n   */\n  public getProjectInfo(): Promise<ProjectInfoResponse> {\n    return this.makeConnectRequest(\"/projects/info\", {\n      method: \"GET\",\n    });\n  }\n\n  /**\n   * Makes a proxy request to the target app API with the specified query parameters and options.\n   *\n   * @returns A promise resolving to the response from the downstream service\n   */\n  public makeProxyRequest(proxyOptions: ProxyApiOpts, targetRequest: ProxyTargetApiRequest): Promise<ProxyResponse> {\n    const url64 = btoa(targetRequest.url).replace(/\\+/g, \"-\")\n      .replace(/\\//g, \"_\")\n      .replace(/=+$/, \"\");\n\n    const headers = targetRequest.options.headers || {};\n\n    const newHeaders = Object.keys(headers).reduce<{ [key: string]: string }>((acc, key) => {\n      acc[`x-pd-proxy-${key}`] = headers[key];\n      return acc;\n    }, {});\n\n    const newOpts: RequestOptions = {\n      method: targetRequest.options.method,\n      headers: newHeaders,\n      params: proxyOptions.searchParams,\n    }\n\n    if (targetRequest.options.body) {\n      newOpts.body = targetRequest.options.body\n    }\n\n    return this.makeConnectRequest(`/proxy/${url64}`, newOpts);\n  }\n}\n","// DO NOT EDIT, SET AT BUILD TIME\nexport const version = \"1.6.9\"\n","// This code is meant to be shared between the browser and server.\nimport type {\n  ConfigurableProps,\n  ConfiguredProps,\n  V1Component,\n  V1DeployedComponent,\n  V1EmittedEvent,\n} from \"./component.js\";\nexport * from \"./component.js\";\nimport { version as sdkVersion } from \"../version.js\";\n\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> =\n    Pick<T, Exclude<keyof T, Keys>>\n    & {\n        [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n    }[Keys]\n\n// Using `RequireAtLeastOne` here prevents the renaming of the attribute to\n// break existing SDK users, by keeping the old attribute name, while ensuring\n// that at least one of the two attributes is present.\ntype ExternalUserId = RequireAtLeastOne<{\n  /**\n   * Your end user ID, for whom you're configuring the component.\n   */\n  externalUserId: string;\n\n  /**\n   * @deprecated Use `externalUserId` instead.\n   */\n  userId: string;\n}, \"externalUserId\" | \"userId\">;\n\ntype RequestInit = globalThis.RequestInit;\n\n/**\n * Options for creating a server-side client.\n * This is used to configure the BackendClient instance.\n */\nexport type ClientOpts = {\n  /**\n   * The environment in which the server client is running (e.g., \"production\",\n   * \"development\").\n   */\n  environment?: string;\n\n  /**\n   * The API host URL. Used by Pipedream employees. Defaults to\n   * \"api.pipedream.com\" if not provided.\n   */\n  apiHost?: string;\n\n  /**\n   * Base domain for workflows. Used for custom domains:\n   * https://pipedream.com/docs/workflows/domains\n   */\n  workflowDomain?: string;\n};\n\n/**\n * Basic ID information of a Pipedream app.\n */\nexport type AppInfo = {\n  /**\n   * ID of the app. Only applies for OAuth apps.\n   */\n  id?: string;\n\n  /**\n   * The name slug of the target app (see\n   * https://pipedream.com/docs/connect/quickstart#find-your-apps-name-slug)\n   */\n  name_slug: string;\n};\n\n/**\n * The types of authentication that Pipedream apps support.\n */\nexport enum AppAuthType {\n  OAuth = \"oauth\",\n  Keys = \"keys\",\n  None = \"none\",\n}\n\n/**\n * Response object for a Pipedream app's metadata\n */\nexport type App = AppInfo & {\n  /**\n   * The human-readable name of the app.\n   */\n  name: string;\n\n  /**\n   * A short description of the app.\n   */\n  description: string;\n\n  /**\n   * The authentication type used by the app.\n   */\n  auth_type: AppAuthType;\n\n  /**\n   * The URL to the app's logo.\n   */\n  img_src: string;\n\n  /**\n   * A JSON string representing the custom fields for the app.\n   */\n  custom_fields_json: string;\n\n  /**\n   * Categories associated with the app.\n   */\n  categories: string[];\n\n  /**\n   * A rough directional ordering of app popularity, subject to changes by Pipedream.\n   */\n  featured_weight: number\n};\n\n/**\n * @deprecated Use `App` instead.\n */\nexport type AppResponse = App;\n\n/**\n * A configuration option for a component's prop.\n */\nexport type PropOption = {\n  label: string;\n  value: string;\n};\n\ntype ConfigureComponentContext = Record<string, unknown>\n\n/**\n * The response received after configuring a component's prop.\n */\nexport type ConfigureComponentResponse = {\n  /**\n   * The options for the prop that's being configured. This field is applicable\n   * when the values don't nicely map to a descriptive string. Useful when the\n   * values for each option are meaningless numeric IDs, unless mapped to a\n   * human-readable string.\n   *\n   * @example a branch with ID `21208123` and name `my-repo/foo` in a Gitlab\n   * repo\n   * ```json\n   * {\n   *   \"label\": \"my-repo/foo\",\n   *   \"value\": 21208123\n   * }\n   * ```\n   */\n  options: PropOption[];\n\n  /**\n   * The options for the prop that's being configured. This field is applicable\n   * when the values themselves are already human-readable strings.\n   */\n  stringOptions: string[];\n\n  /**\n   * A list of errors that occurred during the configuration process.\n   */\n  errors: string[];\n\n  /**\n   * The context object resolved in the options execution (useful for pagination, etc.).\n   * See {@link ConfigureComponentOpts.prevContext}.\n   */\n  context?: ConfigureComponentContext\n};\n\n/**\n * Attributes to use for pagination in API requests.\n */\nexport type RelationOpts = {\n  /**\n   * The retrieve records starting from a certain cursor.\n   */\n  after?: string;\n\n  /**\n   * To retrieve records up until a certain cursor.\n   */\n  before?: string;\n\n  /**\n   * The maximum number of records to retrieve.\n   */\n  limit?: number;\n};\n\n/**\n * Pagination attributes for API responses.\n */\nexport type ResponsePageInfo = {\n  /**\n   * The total number of records available.\n   */\n  total_count: number;\n\n  /**\n   * The number of records returned in the current response.\n   */\n  count: number;\n\n  /**\n   * The cursor to retrieve the next page of records.\n   */\n  start_cursor: string;\n\n  /**\n   * The cursor of the last page of records.\n   */\n  end_cursor: string;\n};\n\n/**\n * The response attributes for paginated API responses.\n */\nexport type PaginationResponse = {\n  /**\n   * The pagination information for the response.\n   */\n  page_info: ResponsePageInfo;\n}\n\n/**\n * @deprecated Use `ConfigureComponentResponse` instead.\n */\nexport type ComponentConfigureResponse = ConfigureComponentResponse;\n\n/**\n * Parameters for the retrieval of apps from the Connect API\n */\nexport type GetAppsOpts = RelationOpts & {\n  /**\n   * A search query to filter the apps.\n   */\n  q?: string;\n  /**\n   * Filter by whether apps have actions in the component registry.\n   */\n  hasActions?: boolean;\n  /**\n   * Filter by whether apps have components in the component registry.\n   */\n  hasComponents?: boolean;\n  /**\n   * Filter by whether apps have triggers in the component registry.\n   */\n  hasTriggers?: boolean;\n};\n\n/**\n * Parameters for the retrieval of accounts from the Connect API\n */\nexport type GetAccountOpts = RelationOpts & {\n  /**\n   * The ID or name slug of the app, in case you want to only retrieve the\n   * accounts for a specific app.\n   */\n  app?: string;\n\n  /**\n   * The ID of the app (if it's an OAuth app), in case you want to only retrieve\n   * the accounts for a specific app.\n   */\n  oauth_app_id?: string;\n\n  /**\n   * Whether to retrieve the account's credentials or not.\n   */\n  include_credentials?: boolean;\n\n  /**\n   * The external user ID associated with the account.\n   */\n  external_user_id?: string;\n};\n\n/**\n * End user account data, returned from the API.\n */\nexport type Account = {\n  /**\n   * The unique ID of the account.\n   */\n  id: string;\n\n  /**\n   * The name of the account.\n   */\n  name: string;\n\n  /**\n   * The external ID associated with the account.\n   */\n  external_id: string;\n\n  /**\n   * Indicates if the account is healthy. Pipedream will periodically retry\n   * token refresh and test requests for unhealthy accounts.\n   */\n  healthy: boolean;\n\n  /**\n   * Indicates if the account is no longer active.\n   */\n  dead: boolean;\n\n  /**\n   * The app associated with the account.\n   */\n  app: AppResponse;\n\n  /**\n   * The date and time the account was created, an ISO 8601 formatted string.\n   */\n  created_at: string;\n\n  /**\n   * The date and time the account was last updated, an ISO 8601 formatted\n   * string.\n   */\n  updated_at: string;\n\n  /**\n   * The credentials associated with the account, if the `include_credentials`\n   * parameter was set to true in the request.\n   */\n  credentials?: Record<string, string>;\n};\n\n/**\n * The request options for reloading a component's props when dealing with\n * dynamic props.\n */\nexport type ReloadComponentPropsOpts = ExternalUserId & {\n  /**\n   * The ID of the component you're configuring. This is the key that uniquely\n   * identifies the component.\n   */\n  componentId: string | ComponentId;\n\n  /**\n   * The props that have already been configured for the component. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The ID of the last prop reload (or none when reloading the props for the\n   * first time).\n   */\n  dynamicPropsId?: string;\n};\n\nexport type ReloadComponentPropsResponse = {\n  // XXX observations\n\n  /**\n   * A list of errors that occurred during the prop reloading process.\n   */\n  errors: string[]\n\n  /**\n   * Dynamic props object containing the dynamic props ID and the dynamic\n   * configurable props for the component.\n   */\n  dynamicProps: {\n    id: string\n    configurableProps: ConfigurableProps\n  }\n}\n\n/**\n * @deprecated Use `ReloadComponentPropsOpts` instead.\n */\nexport type ComponentReloadPropsOpts = ReloadComponentPropsOpts;\n\n/**\n * The request options for configuring a component's prop.\n */\nexport type ConfigureComponentOpts = ExternalUserId & {\n  /**\n   * The ID of the component you're configuring. This is the key that uniquely\n   * identifies the component.\n   */\n  componentId: string | ComponentId;\n\n  /**\n   * The name of the prop you're configuring.\n   */\n  propName: string;\n\n  /**\n   * The props that have already been configured for the component. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The ID of the last prop reconfiguration (if any).\n   */\n  dynamicPropsId?: string;\n\n  /**\n   * A string with the user input if the prop has the useQuery property set to\n   * true. Use with APIs that return items based on a query or search parameter.\n   */\n  query?: string;\n\n  /**\n   * A 0 indexed page number. Use with APIs that accept a\n   * numeric page number for pagination.\n   */\n  page?: number;\n\n  /**\n   * The context object from the previous options execution (useful for pagination, etc.).\n   * See {@link ConfigureComponentResponse.context}.\n   */\n  prevContext?: ConfigureComponentContext;\n};\n\n/**\n * @deprecated Use `ConfigureComponentOpts` instead.\n */\nexport type ComponentConfigureOpts = ConfigureComponentOpts;\n\n/**\n * The request options for retrieving a list of components.\n */\nexport type GetComponentsOpts = RelationOpts & {\n  /**\n   * A search query to filter the components.\n   */\n  q?: string;\n\n  /**\n   * The ID or name slug of the app to filter the components.\n   */\n  app?: string;\n\n  /**\n   * The type of component to filter (either \"trigger\" or \"action\").\n   */\n  componentType?: ComponentType;\n};\n\n/**\n * @deprecated Use `GetComponentsOpts` instead.\n */\nexport type GetComponentOpts = GetComponentsOpts;\n\n/**\n * An object that identifies a single, unique component in Pipedream.\n */\nexport type ComponentId = {\n  /**\n   * The key that uniquely identifies the component.\n   *\n   * @example \"gitlab-list-commits\"\n   * @example \"slack-send-message\"\n   */\n  key: string;\n};\n\n/**\n * Components can be either triggers or actions.\n */\nexport type ComponentType = \"trigger\" | \"action\";\n\n/**\n * Response received after creating a connect token.\n */\nexport type ConnectTokenResponse = {\n  /**\n   * The generated token.\n   */\n  token: string;\n\n  /**\n   * The expiration time of the token in ISO 8601 format.\n   */\n  expires_at: string;\n\n  /**\n   * The Connect Link URL\n   */\n  connect_link_url: string;\n};\n\n/**\n * The response received when retrieving a list of accounts.\n */\nexport type GetAccountsResponse = PaginationResponse & {\n  data: Account[];\n};\n\n/**\n * @deprecated Use `GetAccountsResponse` instead.\n */\nexport type AccountsRequestResponse = GetAccountsResponse;\n\n/**\n * The response received when retrieving a list of apps.\n */\nexport type GetAppsResponse = PaginationResponse & {\n  data: App[];\n};\n\n/**\n * @deprecated Use `GetAppsResponse` instead.\n */\nexport type AppsRequestResponse = GetAppsResponse;\n\n/**\n * The response received when retrieving a specific app.\n */\nexport type GetAppResponse = { data: App; };\n\n/**\n * @deprecated Use `GetAppResponse` instead.\n */\nexport type AppRequestResponse = GetAppResponse;\n\n/**\n * The response received when retrieving a list of components.\n */\nexport type GetComponentsResponse = PaginationResponse & {\n  data: V1Component[];\n};\n\n/**\n * @deprecated Use `GetComponentsResponse` instead.\n */\nexport type ComponentsRequestResponse = GetComponentsResponse;\n\n/**\n * The response received when retrieving a specific component.\n */\nexport type GetComponentResponse = { data: V1Component; };\n\n/**\n * @deprecated Use `GetComponentResponse` instead.\n */\nexport type ComponentRequestResponse = GetComponentResponse;\n\n/**\n * The request options for running an action.\n */\nexport type RunActionOpts = ExternalUserId & {\n  /**\n   * The ID of the action you're running. This is the key that uniquely\n   * identifies the action.\n   */\n  actionId: string | ComponentId;\n\n  /**\n   * The props that have already been configured for the action. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The ID of the last prop reconfiguration (if any).\n   */\n  dynamicPropsId?: string;\n\n  /**\n   * The ID of the File Stash to sync the action's /tmp directory with. This\n   * allows you to persist files across action runs for up to 1 day. If set to\n   * `true` or \"\", a unique stash ID will be generated for you and returned in\n   * the response. If not set, the action will not sync its /tmp directory with\n   * a File Stash.\n   */\n  stashId?: string | boolean;\n};\n\n/**\n * The response received after running an action. See\n * https://pipedream.com/docs/components/api#returning-data-from-steps for more\n * details.\n */\nexport type RunActionResponse = {\n  /**\n   * The key-value pairs resulting from calls to `$.export`\n   */\n  exports: unknown;\n\n  /**\n   * Any logs produced during the execution of the action\n   */\n  os: unknown[];\n\n  /**\n   * The value returned by the action\n   */\n  ret: unknown;\n\n  /**\n   * The ID of the File Stash that was used to sync the action's /tmp directory\n   */\n  stashId?: string;\n};\n\n/**\n * The request options for deploying a trigger.\n */\nexport type DeployTriggerOpts = ExternalUserId & {\n  /**\n   * The ID of the trigger you're deploying. This is the key that uniquely\n   * identifies the trigger.\n   */\n  triggerId: string | ComponentId;\n\n  /**\n   * The props that have already been configured for the trigger. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The ID of the last prop reconfiguration (if any).\n   */\n  dynamicPropsId?: string;\n\n  /**\n   * The ID of the workflow that the trigger will use to send the events it\n   * generates.\n   */\n  workflowId?: string;\n\n  /**\n   * The webhook URL that the trigger will use to send the events it generates.\n   */\n  webhookUrl?: string;\n};\n\n/**\n * The response received after deploying a trigger.\n */\nexport type DeployTriggerResponse = {\n  /**\n   * The contents of the deployed trigger.\n   */\n  data: V1DeployedComponent;\n}\n\n/**\n * The request options for deleting a deployed trigger owned by a particular\n * user.\n */\nexport type DeleteTriggerOpts = {\n  /**\n   * The ID of the trigger you're deleting (`dc_xxxxxxx` for example ).\n   */\n  id: string;\n\n  /**\n   * The end user ID, for whom you deployed the trigger.\n   */\n  externalUserId: string;\n\n  /**\n   * When explicitly set, the API will ignore any errors that occur during the\n   * deactivation hook of the trigger, effectively forcing the deletion of the\n   * trigger.\n   */\n  ignoreHookErrors?: boolean;\n};\n\n/**\n * The request options for retrieving a deployed trigger owned by a particular\n * user.\n */\nexport type GetTriggerOpts = {\n  /**\n   * The ID of the trigger you're retrieving.\n   */\n  id: string;\n\n  /**\n   * Your end user ID, for whom you deployed the trigger.\n   */\n  externalUserId: string;\n};\n\n/**\n * The response received after retrieving a deployed trigger.\n */\nexport type GetTriggerResponse = {\n  /**\n   * The contents of the deployed trigger.\n   */\n  data: V1DeployedComponent;\n};\n\n/**\n * The request options for retrieving the events emitted by a deployed trigger.\n */\nexport type GetTriggerEventsOpts = GetTriggerOpts & {\n  /**\n   * The number of events to retrieve (defaults to 20 if not provided).\n   */\n  limit?: number;\n};\n\n/**\n * The response from retrieving the events emitted by a deployed trigger.\n */\nexport type GetTriggerEventsResponse = {\n  /**\n   * The list of events emitted by the trigger.\n   */\n  data: V1EmittedEvent[];\n};\n\n/**\n * The request options for retrieving the workflows that listen to events\n * emitted by a specific trigger.\n */\nexport type GetTriggerWorkflowsOpts = GetTriggerOpts;\n\n/**\n * The response from retrieving the workflows that listen to events emitted by a\n * specific trigger.\n */\nexport type GetTriggerWorkflowsResponse = {\n  /**\n   * The list of workflow IDs that listen to events emitted by the trigger.\n   */\n  workflow_ids: string[];\n};\n\n/**\n * The request options for updating the workflows that listen to events emitted\n * by a specific trigger.\n */\nexport type UpdateTriggerWorkflowsOpts = GetTriggerOpts & {\n  /**\n   * The workflow IDs that should to events emitted by the trigger.\n   */\n  workflowIds: string[];\n}\n\n/**\n * The request options for retrieving the webhooks that listen to events\n * emitted by a specific trigger.\n */\nexport type GetTriggerWebhooksOpts = GetTriggerOpts;\n\n/**\n * The response from retrieving the webhooks that listen to events emitted by a\n * specific trigger.\n */\nexport type GetTriggerWebhooksResponse = {\n  /**\n   * The list of webhook URLs that listen to events emitted by the trigger.\n   */\n  webhook_urls: string[];\n};\n\n/**\n * The request options for updating the webhooks that listen to events emitted\n * by a specific trigger.\n */\nexport type UpdateTriggerWebhooksOpts = GetTriggerOpts & {\n  /**\n   * The webhook URLs that should to events emitted by the trigger.\n   */\n  webhookUrls: string[];\n}\n\n/**\n * The request options for retrieving a list of deployed triggers for a\n * particular user.\n */\nexport type GetTriggersOpts = RelationOpts & {\n  /**\n   * Your end user ID, for whom you deployed the trigger.\n   */\n  externalUserId: string;\n};\n\n/**\n * The response received after retrieving a list of deployed triggers.\n */\nexport type GetTriggersResponse = PaginationResponse & {\n  /**\n   * The list of deployed triggers.\n   */\n  data: V1DeployedComponent[];\n};\n\n/**\n * The request options for updating a trigger.\n */\nexport type UpdateTriggerOpts = {\n  /**\n   * The ID of the trigger you're updating.\n   */\n  id: string;\n\n  /**\n   * Your end user ID, for whom you deployed the trigger.\n   */\n  externalUserId: string;\n\n  /**\n   * The state to which the trigger should be updated.\n   */\n  active?: boolean;\n\n  /**\n   * The props that have already been configured for the trigger. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps?: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The new name of the trigger.\n   */\n  name?: string;\n};\n\n/**\n * Different ways in which customers can authorize requests to HTTP endpoints\n */\nexport enum HTTPAuthType {\n  None = \"none\",\n  StaticBearer = \"static_bearer_token\",\n  OAuth = \"oauth\",\n}\n\n/**\n * Error response returned by the API in case of an error.\n */\nexport type ErrorResponse = {\n  /**\n   * The error message returned by the API.\n   */\n  error: string;\n};\n\n/**\n * A generic API response that can either be a success or an error.\n */\nexport type ConnectAPIResponse<T> = T | ErrorResponse;\n\n/**\n * Options for making a request to the Pipedream API.\n */\nexport interface RequestOptions extends Omit<RequestInit, \"headers\" | \"body\"> {\n  /**\n   * Query parameters to include in the request URL.\n   */\n  params?: Record<string, string | boolean | number | null>;\n\n  /**\n   * Headers to include in the request.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * The URL to make the request to.\n   */\n  baseURL?: string;\n\n  /**\n   * The body of the request.\n   */\n  body?: Record<string, unknown> | string | FormData | URLSearchParams | null;\n}\n\nexport interface AsyncRequestOptions extends RequestOptions {\n  body: { async_handle: string; } & Required<RequestOptions[\"body\"]>;\n}\n\nconst SENSITIVE_KEYS = [\n  \"token\",\n  \"password\",\n  \"secret\",\n  \"apiKey\",\n  \"authorization\",\n  \"auth\",\n  \"key\",\n  \"access_token\",\n];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction sanitize(value: any, seen = new WeakSet()): any {\n  if (value === null || value === undefined) return value;\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) return \"[CIRCULAR]\";\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      return value.map((v) => sanitize(v, seen));\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const sanitizedObj: Record<string, any> = {};\n    for (const [\n      k,\n      v,\n    ] of Object.entries(value)) {\n      const isSensitiveKey = SENSITIVE_KEYS.some((sensitiveKey) =>\n        k.toLowerCase().includes(sensitiveKey.toLowerCase()));\n      sanitizedObj[k] = isSensitiveKey\n        ? \"[REDACTED]\"\n        : sanitize(v, seen);\n    }\n    return sanitizedObj;\n  }\n\n  return value; // numbers, booleans, functions, etc.\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function DEBUG(...args: any[]) {\n  if (\n    typeof process !== \"undefined\" &&\n    typeof process.env !== \"undefined\" &&\n    process.env.PD_SDK_DEBUG === \"true\"\n  ) {\n    const safeArgs = args.map((arg) => sanitize(arg));\n    console.log(\"[PD_SDK_DEBUG]\", ...safeArgs);\n  }\n}\n\n/**\n * A client for interacting with the Pipedream Connect API on the server-side.\n */\nexport abstract class BaseClient {\n  version = sdkVersion;\n  protected apiHost: string;\n  protected readonly baseApiUrl: string;\n  protected environment: string;\n  protected projectId?: string;\n  protected readonly workflowDomain: string;\n\n  /**\n   * Constructs a new BackendClient instance.\n   *\n   * @param opts - The options for configuring the server client.\n   */\n  constructor(opts: ClientOpts) {\n    this.environment = opts.environment ?? \"production\";\n\n    const {\n      apiHost = \"api.pipedream.com\",\n      workflowDomain = \"m.pipedream.net\",\n    } = opts;\n    this.apiHost = apiHost;\n    this.baseApiUrl = `https://${apiHost}/v1`;\n    this.workflowDomain = workflowDomain;\n  }\n\n  /**\n   * Retrieves the current environment the client is configured to use.\n   * @returns {string} The current environment.\n   */\n  public getEnvironment(): string {\n    return this.environment;\n  }\n\n  /**\n   * Makes an HTTP request\n   *\n   * @template T - The expected response type.\n   * @param path - The API endpoint path.\n   * @param opts - The options for the request.\n   * @returns A promise resolving to the API response.\n   * @throws Will throw an error if the response status is not OK.\n   */\n  public async makeRequest<T>(\n    path: string,\n    opts: RequestOptions = {},\n  ): Promise<T> {\n    const {\n      params,\n      headers: customHeaders,\n      body,\n      method = \"GET\",\n      baseURL = this.baseApiUrl,\n      ...fetchOpts\n    } = opts;\n\n    const url = new URL(`${baseURL}${path}`);\n\n    if (params) {\n      for (const [\n        key,\n        value,\n      ] of Object.entries(params)) {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      }\n    }\n\n    const headers: Record<string, string> = {\n      ...customHeaders,\n      \"X-PD-SDK-Version\": sdkVersion,\n      \"X-PD-Environment\": this.environment,\n    };\n\n    let processedBody: string | URLSearchParams | FormData | null = null;\n\n    if (body) {\n      if (\n        body instanceof FormData ||\n        body instanceof URLSearchParams ||\n        typeof body === \"string\"\n      ) {\n        // For FormData, URLSearchParams, or strings, pass the body as-is\n        processedBody = body;\n      } else {\n        // For objects, assume it's JSON and serialize it\n        processedBody = JSON.stringify(body);\n        // Set the Content-Type header to application/json if not already set\n        headers[\"Content-Type\"] = headers[\"Content-Type\"] || \"application/json\";\n      }\n    }\n\n    const requestOptions: RequestInit = {\n      method,\n      headers,\n      ...fetchOpts,\n    };\n\n    if (\n      [\n        \"POST\",\n        \"PUT\",\n        \"PATCH\",\n      ].includes(method.toUpperCase()) &&\n      processedBody\n    ) {\n      requestOptions.body = processedBody;\n    }\n\n    const response: Response = await fetch(url.toString(), requestOptions);\n\n    const rawBody = await response.text();\n\n    DEBUG(\"status: \", response.status)\n    DEBUG(\"url: \", url.toString())\n    DEBUG(\"requestOptions: \", requestOptions)\n    DEBUG(\"rawBody: \", rawBody)\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}, body: ${rawBody}`);\n    }\n\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && contentType.includes(\"application/json\")) {\n      try {\n        const json = JSON.parse(rawBody);\n        return json as T;\n      } catch (err) {\n        DEBUG(\"Couldn't parse json, falling back to raw\", err)\n      }\n    }\n\n    return rawBody as unknown as T;\n  }\n\n  protected abstract authHeaders(): string | Promise<string>;\n\n  /**\n   * Makes a request to the Pipedream API with appropriate authorization.\n   *\n   * @template T - The expected response type.\n   * @param path - The API endpoint path.\n   * @param opts - The options for the request.\n   * @returns A promise resolving to the API response.\n   * @throws Will throw an error if the response status is not OK.\n   */\n  public async makeAuthorizedRequest<T>(\n    path: string,\n    opts: RequestOptions = {},\n  ): Promise<T> {\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      ...opts.headers,\n      \"Authorization\": await this.authHeaders(),\n    };\n\n    return this.makeRequest(path, {\n      ...opts,\n      headers,\n    });\n  }\n\n  /**\n   * Makes a request to the Connect API using Connect authorization.\n   *\n   * @template T - The expected response type.\n   * @param path - The API endpoint path.\n   * @param opts - The options for the request.\n   * @returns A promise resolving to the API response.\n   */\n  protected makeConnectRequest<T>(\n    path: string,\n    opts: RequestOptions = {},\n  ): Promise<T> {\n    let fullPath = \"/connect\";\n    if (this.projectId) {\n      fullPath += `/${this.projectId}`;\n    }\n    fullPath += path;\n    return this.makeAuthorizedRequest(fullPath, opts);\n  }\n\n  /**\n   * Retrieves the list of accounts associated with the project.\n   *\n   * @param params - The query parameters for retrieving accounts.\n   * @returns A promise resolving to a list of accounts.\n   *\n   * @example\n   * ```typescript\n   * const accounts = await client.getAccounts({ include_credentials: true });\n   * console.log(accounts);\n   * ```\n   */\n  public getAccounts(params: GetAccountOpts = {}) {\n    return this.makeConnectRequest<GetAccountsResponse>(\"/accounts\", {\n      method: \"GET\",\n      params,\n    });\n  }\n\n  /**\n   * Retrieves the list of apps available in Pipedream.\n   *\n   * @param opts - The options for retrieving apps.\n   * @returns A promise resolving to a list of apps.\n   *\n   * @example\n   * ```typescript\n   * const apps = await client.getApps({ q: \"slack\" });\n   * console.log(apps);\n   * ```\n   */\n  public getApps(opts?: GetAppsOpts) {\n    const params: Record<string, string> = {};\n    if (opts?.q) {\n      params.q = opts.q;\n    }\n    if (opts?.hasActions != null) {\n      params.has_actions = opts.hasActions\n        ? \"1\"\n        : \"0\";\n    }\n    if (opts?.hasComponents != null) {\n      params.has_components = opts.hasComponents\n        ? \"1\"\n        : \"0\";\n    }\n    if (opts?.hasTriggers != null) {\n      params.has_triggers = opts.hasTriggers\n        ? \"1\"\n        : \"0\";\n    }\n\n    this.addRelationOpts(params, opts);\n    return this.makeAuthorizedRequest<GetAppsResponse>(\n      \"/apps\",\n      {\n        method: \"GET\",\n        params,\n      },\n    );\n  }\n\n  /**\n   * @deprecated Use `getApps` instead.\n   */\n  public apps(opts?: GetAppsOpts) {\n    return this.getApps(opts);\n  }\n\n  /**\n   * Retrieves the metadata for a specific app.\n   *\n   * @param idOrNameSlug - The ID or name slug of the app.\n   * @returns A promise resolving to the app metadata.\n   *\n   * @example\n   * ```typescript\n   * const app = await client.getApp(\"slack\");\n   * console.log(app);\n   * ```\n   */\n  public getApp(idOrNameSlug: string) {\n    const url = `/apps/${idOrNameSlug}`;\n    return this.makeAuthorizedRequest<GetAppResponse>(url, {\n      method: \"GET\",\n    });\n  }\n\n  /**\n   * @deprecated Use `getApp` instead.\n   */\n  public app(idOrNameSlug: string) {\n    return this.getApp(idOrNameSlug);\n  }\n\n  /**\n   * Retrieves the list of components available in Pipedream.\n   *\n   * @param opts - The options for retrieving components.\n   * @returns A promise resolving to a list of components.\n   *\n   * @example\n   * ```typescript\n   * const components = await client.getComponents({ q: \"slack\" });\n   * console.log(components);\n   * ```\n   */\n  public getComponents(opts?: GetComponentsOpts) {\n    const params: Record<string, string> = {};\n    if (opts?.app) {\n      params.app = opts.app;\n    }\n    if (opts?.q) {\n      params.q = opts.q;\n    }\n    this.addRelationOpts(params, opts, 20);\n    // XXX can just use /components and ?type instead when supported\n    let path = \"/components\";\n    if (opts?.componentType === \"trigger\") {\n      path = \"/triggers\";\n    } else if (opts?.componentType === \"action\") {\n      path = \"/actions\";\n    }\n    // XXX Is V1Component the correct type for triggers and actions?\n    return this.makeConnectRequest<GetComponentsResponse>(path, {\n      method: \"GET\",\n      params,\n    });\n  }\n\n  /**\n   * @deprecated Use `getComponents` instead.\n   */\n  public components(opts?: GetComponentOpts) {\n    return this.getComponents(opts);\n  }\n\n  /**\n   * Retrieves the metadata for a specific component.\n   *\n   * @param id - The identifier of the component.\n   * @returns A promise resolving to the component metadata.\n   *\n   * @example\n   * ```typescript\n   * const component = await client.getComponent(\"slack-send-message\");\n   * console.log(component);\n   * ```\n   */\n  public getComponent(id: ComponentId) {\n    const { key } = id;\n    const path = `/components/${key}`;\n    return this.makeConnectRequest<GetComponentResponse>(path, {\n      method: \"GET\",\n    });\n  }\n\n  /**\n   * @deprecated Use `getComponent` instead.\n   */\n  public component({ key }: { key: string; }) {\n    return this.getComponent({\n      key,\n    });\n  }\n\n  /**\n   * Configure the next component's prop, based on the current component's\n   * configuration.\n   *\n   * @param opts - The options for configuring the component.\n   * @returns A promise resolving to the response from the configuration.\n   *\n   * @example\n   * ```typescript\n   * const { options } = await client.configureComponent({\n   *  externalUserId: \"jverce\",\n   *  componentId: {\n   *    key: \"slack-send-message\",\n   *  },\n   *  propName: \"channel\",\n   *  configuredProps: {\n   *    slack: {\n    *     authProvisionId: \"apn_z8hD1b4\",\n    *   },\n   *  },\n   * });\n   * console.log(options);\n   */\n  public configureComponent(opts: ConfigureComponentOpts) {\n    const {\n      userId,\n      externalUserId = userId,\n      componentId,\n    } = opts;\n\n    const id = typeof componentId === \"object\"\n      ? componentId.key\n      : componentId;\n\n    const body = {\n      external_user_id: externalUserId,\n      id,\n      prop_name: opts.propName,\n      configured_props: opts.configuredProps,\n      dynamic_props_id: opts.dynamicPropsId,\n      page: opts.page,\n      prev_context: opts.prevContext,\n      query: opts.query,\n    };\n    return this.makeConnectRequest<ConfigureComponentResponse>(\"/components/configure\", {\n      method: \"POST\",\n      body,\n    });\n  }\n\n  /**\n   * @deprecated Use `configureComponent` instead.\n   */\n  public componentConfigure(opts: ComponentConfigureOpts) {\n    return this.configureComponent(opts);\n  }\n\n  /**\n   * Reload the component prop's based on the current component's configuration.\n   * This applies to dynamic props (see the docs for more info:\n   * https://pipedream.com/docs/components/api#dynamic-props).\n   *\n   * @param opts - The options for reloading the component's props.\n   * @returns A promise resolving to the response from the reload.\n   *\n   * @example\n   * ```typescript\n   * const { dynamicProps } = await client.reloadComponentProps({\n   *  externalUserId: \"jverce\",\n   *  componentId: {\n   *    key: \"slack-send-message\",\n   *  },\n   *  configuredProps: {\n   *    slack: {\n   *      authProvisionId: \"apn_z8hD1b4\",\n   *    },\n   *  },\n   * });\n   *\n   * const { configurableProps, id: dynamicPropsId } = dynamicProps;\n   * // Use `dynamicPropsId` to configure the next prop\n   * // Use `configurableProps` to display the new set of props to the user\n   */\n  public reloadComponentProps(opts: ReloadComponentPropsOpts) {\n    const {\n      userId,\n      externalUserId = userId,\n      componentId,\n    } = opts;\n\n    const id = typeof componentId === \"object\"\n      ? componentId.key\n      : componentId;\n\n    // RpcActionReloadPropsInput\n    const body = {\n      external_user_id: externalUserId,\n      id,\n      configured_props: opts.configuredProps,\n      dynamic_props_id: opts.dynamicPropsId,\n    };\n\n    return this.makeConnectRequest<ReloadComponentPropsResponse>(\n      \"/components/props\", {\n      // TODO trigger\n        method: \"POST\",\n        body,\n      },\n    );\n  }\n\n  /**\n   * @deprecated Use `reloadComponentProps` instead.\n   */\n  public componentReloadProps(opts: ComponentReloadPropsOpts) {\n    return this.reloadComponentProps(opts);\n  }\n\n  /**\n   * Invoke an action component for a Pipedream Connect user in a project\n   *\n   * @param opts - The options for running the action.\n   * @returns A promise resolving to the response from the action's execution.\n   *\n   * @example\n   * ```typescript\n   * const response = await client.runAction({\n   *   externalUserId: \"jverce\",\n   *   actionId: {\n   *     key: \"gitlab-list-commits\",\n   *   },\n   *   configuredProps: {\n   *     gitlab: {\n   *       authProvisionId: \"apn_z8hD1b4\"\n   *     },\n   *     projectId: 21208123,\n   *     refName: \"10-0-stable-ee\",\n   *   },\n   * });\n   * console.log(response);\n   * ```\n   */\n  public runAction(opts: RunActionOpts) {\n    const {\n      userId,\n      externalUserId = userId,\n      actionId,\n    } = opts;\n\n    const id = typeof actionId === \"object\"\n      ? actionId.key\n      : actionId;\n\n    const body = {\n      external_user_id: externalUserId,\n      id,\n      configured_props: opts.configuredProps,\n      dynamic_props_id: opts.dynamicPropsId,\n      stash_id: opts.stashId,\n    };\n    return this.makeConnectRequest<RunActionResponse>(\"/actions/run\", {\n      method: \"POST\",\n      body,\n    });\n  }\n\n  /**\n   * @deprecated Use `runAction` instead.\n   */\n  public actionRun(opts: RunActionOpts) {\n    return this.runAction(opts);\n  }\n\n  /**\n   * Deploy a trigger component for a Pipedream Connect user in a project\n   *\n   * @param opts - The options for deploying the trigger.\n   * @returns A promise resolving to the response from the trigger's deployment.\n   *\n   * @example\n   * ```typescript\n   * const response = await client.deployTrigger({\n   *   externalUserId: \"jverce\",\n   *   triggerId: {\n   *     key: \"gitlab-new-issue\",\n   *   },\n   *   configuredProps: {\n   *     gitlab: {\n   *       authProvisionId: \"apn_z8hD1b4\",\n   *     },\n   *     projectId: 21208123,\n   *   },\n   *   webhookUrl: \"https://dest.mydomain.com\",\n   * });\n   * console.log(response);\n   */\n  public deployTrigger(opts: DeployTriggerOpts) {\n    const {\n      userId,\n      externalUserId = userId,\n      triggerId,\n    } = opts;\n\n    const id = typeof triggerId === \"object\"\n      ? triggerId.key\n      : triggerId;\n\n    const body = {\n      external_user_id: externalUserId,\n      id,\n      configured_props: opts.configuredProps,\n      dynamic_props_id: opts.dynamicPropsId,\n      workflow_id: opts.workflowId,\n      webhook_url: opts.webhookUrl,\n    };\n    return this.makeConnectRequest<DeployTriggerResponse>(\"/triggers/deploy\", {\n      method: \"POST\",\n      body,\n    });\n  }\n\n  /**\n   * @deprecated Use `deployTrigger` instead.\n   */\n  public triggerDeploy(opts: DeployTriggerOpts) {\n    return this.deployTrigger(opts);\n  }\n\n  /**\n   * Deletes a specific trigger.\n   *\n   * @param opts - The options for deleting the trigger.\n   * @returns No content\n   */\n  public deleteTrigger(opts: DeleteTriggerOpts) {\n    const {\n      id,\n      externalUserId,\n      ignoreHookErrors = null,\n    } = opts;\n\n    return this.makeConnectRequest<void>(`/deployed-triggers/${id}`, {\n      method: \"DELETE\",\n      params: {\n        external_user_id: externalUserId,\n        ignore_hook_errors: ignoreHookErrors,\n      },\n    });\n  }\n\n  /**\n   * Retrieves the metadata for a specific trigger.\n   *\n   * @param opts - The options for retrieving the trigger.\n   * @returns A promise resolving to the trigger metadata.\n   */\n  public getTrigger(opts: GetTriggerOpts) {\n    const {\n      id,\n      externalUserId,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerResponse>(`/deployed-triggers/${id}`, {\n      method: \"GET\",\n      params: {\n        external_user_id: externalUserId,\n      },\n    });\n  }\n\n  /**\n   * Retrieves the metadata for all deployed triggers\n   *\n   * @param opts - The options for retrieving the triggers.\n   * @returns A promise resolving to a list of the trigger metadata.\n   */\n  public getTriggers(opts: GetTriggersOpts) {\n    const { externalUserId } = opts;\n\n    return this.makeConnectRequest<GetTriggersResponse>(\"/deployed-triggers\", {\n      method: \"GET\",\n      params: {\n        external_user_id: externalUserId,\n      },\n    });\n  }\n\n  /**\n   * Updates a specific trigger.\n   *\n   * @param opts - The options for updating the trigger.\n   * @returns A promise resolving to the trigger metadata.\n   */\n  public updateTrigger(opts: UpdateTriggerOpts) {\n    const {\n      id,\n      externalUserId,\n      active = null,\n      configuredProps = null,\n      name = null,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerResponse>(`/deployed-triggers/${id}`, {\n      method: \"PUT\",\n      params: {\n        external_user_id: externalUserId,\n      },\n      body: {\n        active,\n        configured_props: configuredProps,\n        name,\n      },\n    });\n  }\n\n  /**\n   * Retrieves the last events emitted by a specific trigger.\n   *\n   * @param opts - The options for retrieving the trigger events.\n   * @returns A promise resolving to a list of emitted events.\n   */\n  public getTriggerEvents(opts: GetTriggerEventsOpts) {\n    const {\n      id,\n      externalUserId,\n      limit = null,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerEventsResponse>(\n      `/deployed-triggers/${id}/events`, {\n        method: \"GET\",\n        params: {\n          external_user_id: externalUserId,\n          n: limit,\n        },\n      },\n    );\n  }\n\n  /**\n   * Retrieves the list of workflows to which the trigger emits events.\n   *\n   * @param opts - The options for retrieving the listening workflows.\n   * @returns A promise resolving to a list of workflows.\n   */\n  public getTriggerWorkflows(opts: GetTriggerWorkflowsOpts) {\n    const {\n      id,\n      externalUserId,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerWorkflowsResponse>(\n      `/deployed-triggers/${id}/pipelines`, {\n        method: \"GET\",\n        params: {\n          external_user_id: externalUserId,\n        },\n      },\n    );\n  }\n\n  /**\n   * Updates the list of workflows to which the trigger will emit events.\n   *\n   * @param opts - The options for updating the listening workflows.\n   * @throws If `workflowIds` is not an array.\n   * @returns A promise resolving to a list of workflows.\n   */\n  public updateTriggerWorkflows(opts: UpdateTriggerWorkflowsOpts) {\n    const {\n      id,\n      externalUserId,\n      workflowIds,\n    } = opts;\n\n    if (!Array.isArray(workflowIds)) {\n      throw new Error(\"workflowIds must be an array\");\n    }\n\n    return this.makeConnectRequest<GetTriggerWorkflowsResponse>(\n      `/deployed-triggers/${id}/pipelines`, {\n        method: \"PUT\",\n        params: {\n          external_user_id: externalUserId,\n        },\n        body: {\n          workflow_ids: workflowIds,\n        },\n      },\n    );\n  }\n\n  /**\n   * Retrieves the list of webhooks to which the trigger emits events.\n   *\n   * @param opts - The options for retrieving the listening webhooks.\n   * @returns A promise resolving to a list of webhooks.\n   */\n  public getTriggerWebhooks(opts: GetTriggerWebhooksOpts) {\n    const {\n      id,\n      externalUserId,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerWebhooksResponse>(\n      `/deployed-triggers/${id}/webhooks`, {\n        method: \"GET\",\n        params: {\n          external_user_id: externalUserId,\n        },\n      },\n    );\n  }\n\n  /**\n   * Updates the list of webhooks to which the trigger will emit events.\n   *\n   * @param opts - The options for updating the listening webhooks.\n   * @throws If `webhookUrls` is not an array.\n   * @returns A promise resolving to a list of webhooks.\n   */\n  public updateTriggerWebhooks(opts: UpdateTriggerWebhooksOpts) {\n    const {\n      id,\n      externalUserId,\n      webhookUrls,\n    } = opts;\n\n    if (!Array.isArray(webhookUrls)) {\n      throw new Error(\"webhookUrls must be an array\");\n    }\n\n    return this.makeConnectRequest<GetTriggerWebhooksResponse>(\n      `/deployed-triggers/${id}/webhooks`, {\n        method: \"PUT\",\n        params: {\n          external_user_id: externalUserId,\n        },\n        body: {\n          webhook_urls: webhookUrls,\n        },\n      },\n    );\n  }\n\n  /**\n   * Builds a full workflow URL based on the input.\n   *\n   * @param input - Either a full URL (with or without protocol) or just an\n   * endpoint ID.\n   * @returns The fully constructed URL.\n   * @throws If the input is a malformed URL, throws an error with a clear\n   * message.\n   *\n   * @example\n   * ```typescript\n   * // Full URL input\n   * this.buildWorkflowUrl(\"https://en123.m.pipedream.net\");\n   * // Returns: \"https://en123.m.pipedream.net\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Partial URL (without protocol)\n   * this.buildWorkflowUrl(\"en123.m.pipedream.net\");\n   * // Returns: \"https://en123.m.pipedream.net\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // ID only input\n   * this.buildWorkflowUrl(\"en123\");\n   * // Returns: \"https://en123.yourdomain.com\" (where `yourdomain.com` is set in `workflowDomain`)\n   * ```\n   */\n  private buildWorkflowUrl(input: string): string {\n    const sanitizedInput = input\n      .trim()\n      .replace(/[^\\w-./:]/g, \"\")\n      .toLowerCase();\n    if (!sanitizedInput) {\n      throw new Error(\"URL or endpoint ID is required\");\n    }\n\n    let url: string;\n    const isUrl =\n      sanitizedInput.includes(\".\") || sanitizedInput.startsWith(\"http\");\n\n    if (isUrl) {\n      // Try to parse the input as a URL\n      let parsedUrl: URL;\n      try {\n        const urlString = sanitizedInput.startsWith(\"http\")\n          ? sanitizedInput\n          : `https://${sanitizedInput}`;\n        parsedUrl = new URL(urlString);\n      } catch {\n        throw new Error(`\n          The provided URL is malformed: \"${sanitizedInput}\".\n          Please provide a valid URL.\n        `);\n      }\n\n      // Validate the hostname to prevent potential DNS rebinding attacks\n      if (!parsedUrl.hostname.endsWith(this.workflowDomain)) {\n        throw new Error(\n          `Invalid workflow domain. URL must end with ${this.workflowDomain}`,\n        );\n      }\n\n      url = parsedUrl.href;\n    } else {\n      // If the input is an ID, construct the full URL using the base domain\n      if (!/^e(n|o)[a-z0-9-]+$/i.test(sanitizedInput)) {\n        throw new Error(`\n          Invalid endpoint ID format.\n          Must contain only letters, numbers, and hyphens, and start with either \"en\" or \"eo\".\n        `);\n      }\n\n      url = `https://${sanitizedInput}.${this.workflowDomain}`;\n    }\n\n    return url;\n  }\n\n  /**\n   * Invokes a workflow using the URL of its HTTP interface(s), by sending an\n   *\n   * @param urlOrEndpoint - The URL of the workflow's HTTP interface, or the ID of the endpoint\n   * @param opts - The options for the request.\n   * @param opts.body - The body of the request. It must be a JSON-serializable\n   * value (e.g. an object, null, a string, etc.).\n   * @param opts.headers - The headers to include in the request. Note that the\n   * Authorization header will always be set with an OAuth access token\n   * retrieved by the client.\n   * @param authType - The type of authorization to use for the request.\n   * @returns A promise resolving to the response from the workflow.\n   *\n   * @example\n   * ```typescript\n   * const response: JSON = await client.invokeWorkflow(\n   *   \"https://en-your-endpoint.m.pipedream.net\",\n   *   {\n   *     body: {\n   *       foo: 123,\n   *       bar: \"abc\",\n   *       baz: null,\n   *     },\n   *     headers: {\n   *       \"Accept\": \"application/json\",\n   *     },\n   *   },\n   *   \"oauth\",\n   * );\n   * console.log(response);\n   * ```\n   */\n  public async invokeWorkflow(\n    urlOrEndpoint: string,\n    opts: RequestOptions = {},\n    authType: HTTPAuthType = HTTPAuthType.None,\n  ): Promise<unknown> {\n    const {\n      body, headers = {},\n    } = opts;\n\n    const url = this.buildWorkflowUrl(urlOrEndpoint);\n\n    let authHeader: string | undefined;\n    switch (authType) {\n    case HTTPAuthType.StaticBearer:\n      // It's expected that users will pass their own Authorization header in\n      // the static bearer case\n      authHeader = headers[\"Authorization\"];\n      break;\n    case HTTPAuthType.OAuth:\n      authHeader = await this.authHeaders(); // TODO How to handle this client side? We should pass the auth even if it's not OAuth\n      break;\n    default:\n      break;\n    }\n\n    return this.makeRequest(\"\", {\n      ...opts,\n      baseURL: url,\n      method: opts.method || \"POST\", // Default to POST if not specified\n      headers: authHeader\n        ? {\n          ...headers,\n          Authorization: authHeader,\n        }\n        : headers,\n      body,\n    });\n  }\n\n  /**\n   * Invokes a workflow for a Pipedream Connect user in a project\n   *\n   * @param url - The URL of the workflow's HTTP interface.\n   * @param externalUserId — Your end user ID, for whom you're invoking the\n   * workflow.\n   * @param opts - The options for the request.\n   * @param opts.body - The body of the request. It must be a JSON-serializable\n   * value (e.g. an object, null, a string, etc.).\n   * @param opts.headers - The headers to include in the request. Note that the\n   * Authorization header will always be set with an OAuth access token\n   * retrieved by the client.\n   * @returns A promise resolving to the response from the workflow.\n   *\n   * @example\n   * ```typescript\n   * const response = await client.invokeWorkflowForExternalUser(\n   *   \"https://your-workflow-url.m.pipedream.net\",\n   *   \"your-external-user-id\",\n   *   {\n   *     body: {\n   *       foo: 123,\n   *       bar: \"abc\",\n   *       baz: null,\n   *     },\n   *     headers: {\n   *       \"Accept\": \"application/json\",\n   *     },\n   *   },\n   * );\n   * console.log(response);\n   * ```\n   */\n  public async invokeWorkflowForExternalUser(\n    url: string,\n    externalUserId: string,\n    opts: RequestOptions = {},\n  ): Promise<unknown> {\n    if (!externalUserId?.trim()) {\n      throw new Error(\"External user ID is required\");\n    }\n\n    if (!url.trim()) {\n      throw new Error(\"Workflow URL is required\");\n    }\n\n    if (!(await this.authHeaders())) {\n      throw new Error(\n        // TODO Test that this works with token auth\n        \"OAuth or token is required for invoking workflows for external users. Please pass credentials for a valid OAuth client\",\n      );\n    }\n\n    const { headers = {} } = opts;\n    return this.invokeWorkflow(\n      url,\n      {\n        ...opts,\n        headers: {\n          ...headers,\n          \"X-PD-External-User-ID\": externalUserId,\n        },\n      },\n      HTTPAuthType.OAuth,\n    ); // OAuth auth is required for invoking workflows for external users\n  }\n\n  private addRelationOpts(params: Record<string, string>, opts?: RelationOpts, defaultLimit?: number) {\n    if (opts?.limit != null) {\n      params.limit = \"\" + opts.limit;\n    }\n    if (defaultLimit != null && !params.limit) {\n      params.limit = \"\" + defaultLimit;\n    }\n    if (opts?.after) {\n      params.after = opts.after;\n    }\n    if (opts?.before) {\n      params.before = opts.before;\n    }\n  }\n}\n"],"mappings":"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","names":["oauth","version","AppAuthType","HTTPAuthType","SENSITIVE_KEYS","sanitize","value","seen","v","sanitizedObj","k","isSensitiveKey","sensitiveKey","DEBUG","args","safeArgs","arg","BaseClient","opts","version","_a","apiHost","workflowDomain","path","params","customHeaders","body","method","baseURL","fetchOpts","__objRest","url","key","headers","__spreadProps","__spreadValues","processedBody","requestOptions","response","rawBody","contentType","err","fullPath","idOrNameSlug","id","userId","externalUserId","componentId","actionId","triggerId","ignoreHookErrors","active","configuredProps","name","limit","workflowIds","webhookUrls","input","sanitizedInput","parsedUrl","urlString","e","urlOrEndpoint","authType","authHeader","defaultLimit","createBackendClient","opts","BackendClient","BaseClient","environment","clientId","clientSecret","tokenHost","client","clientAuth","as","attempts","maxAttempts","resolve","parameters","response","oauthTokenResponse","e","body","__spreadProps","__spreadValues","accountId","params","appId","externalId","proxyOptions","targetRequest","url64","headers","newHeaders","acc","key","newOpts"]}
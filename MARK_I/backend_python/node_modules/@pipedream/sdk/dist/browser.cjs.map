{"version":3,"sources":["../src/browser/index.ts","../src/version.ts","../src/shared/index.ts"],"sourcesContent":["// This code is meant to be run client-side. Never provide project keys to the\n// browser client, or make API requests to the Pipedream API to fetch\n// credentials. The browser client is meant for initiating browser-specific\n// operations, like connecting accounts via Pipedream Connect. See the server/\n// directory for the server client.\n\nimport {\n  AccountsRequestResponse,\n  BaseClient,\n  GetAccountOpts,\n  type ConnectTokenResponse,\n} from \"../shared/index.js\";\nexport type * from \"../shared/index.js\";\n\n/**\n * Options for creating a browser-side client. This is used to configure the\n * BrowserClient instance.\n */\ntype CreateBrowserClientOpts = {\n  /**\n   * @deprecated environment is set on the server when generating the client token\n   */\n  environment?: string;\n\n  /**\n   * The frontend host URL. Used by Pipedream employees only. Defaults to\n   * \"pipedream.com\" if not provided.\n   */\n  frontendHost?: string;\n\n  /**\n   * The API host URL. Used by Pipedream employees. Defaults to\n   * \"api.pipedream.com\" if not provided.\n   */\n  apiHost?: string;\n\n  /**\n   * Will be called whenever we need a new token.\n   *\n   * The callback function should return the response from\n   * `serverClient.createConnectToken`.\n   */\n  tokenCallback?: TokenCallback;\n\n  /**\n   * An external user ID associated with the token.\n   */\n  externalUserId?: string;\n};\n\nexport type TokenCallback = (opts: {\n  externalUserId: string;\n}) => Promise<ConnectTokenResponse>;\n\n/**\n * The name slug for an app, a unique, human-readable identifier like \"github\"\n * or \"google_sheets\". Find this in the Authentication section for any app's\n * page at https://pipedream.com/apps. For more information about name slugs,\n * see https://pipedream.com/docs/connect/quickstart#find-your-apps-name-slug.\n */\ntype AppNameSlug = string;\n\n/**\n * The result of a successful connection.\n */\ntype ConnectResult = {\n  /**\n   * The unique identifier of the connected account.\n   */\n  id: string;\n};\n\n/**\n * The status when the Connect dialog is closed.\n */\ntype ConnectStatus = {\n  /**\n   * Whether the connection was successful (account was connected).\n   */\n  successful: boolean;\n  /**\n   * Whether the connection process was completed (vs user closing early).\n   */\n  completed: boolean;\n};\n\n/**\n * Custom error class for handling connection errors.\n */\nclass ConnectError extends Error {}\n\n/**\n * Options for starting the connection process.\n */\ntype StartConnectOpts = {\n  /**\n   * The token used for authenticating the connection.\n   *\n   * Optional if client already initialized with token\n   */\n  token?: string;\n\n  /**\n   * The app to connect to, either as an ID or an object containing the ID.\n   */\n  app: AppNameSlug;\n\n  /**\n   * The OAuth app ID to connect to.\n   */\n  oauthAppId?: string;\n\n  /**\n   * Callback function to be called upon successful connection.\n   *\n   * @param res - The result of the connection.\n   */\n  onSuccess?: (res: ConnectResult) => void;\n\n  /**\n   * Callback function to be called if an error occurs during the connection.\n   *\n   * @param err - The error that occurred during the connection.\n   */\n  onError?: (err: ConnectError) => void;\n\n  /**\n   * Callback function to be called when the Connect iFrame is closed.\n   *\n   * @param status - The status of the connection when closed.\n   */\n  onClose?: (status: ConnectStatus) => void;\n};\n\n/**\n * Creates a new instance of `BrowserClient` with the provided options.\n *\n * @example\n * ```typescript\n    const client = createFrontendClient({\n      tokenCallback,\n      externalUserId,\n    });\n * ```\n * @param opts - The options for creating the browser client.\n * @returns A new instance of `BrowserClient`.\n */\nexport function createFrontendClient(opts: CreateBrowserClientOpts = {}) {\n  return new BrowserClient(opts);\n}\n\n/**\n * A client for interacting with the Pipedream Connect API from the browser.\n */\nexport class BrowserClient extends BaseClient {\n  private baseURL: string;\n  private iframeURL: string;\n  private iframe?: HTMLIFrameElement;\n  private iframeId = 0;\n  private tokenCallback?: TokenCallback;\n  private _token?: string;\n  private _tokenExpiresAt?: Date;\n  private _tokenRequest?: Promise<string>;\n  externalUserId?: string;\n\n  /**\n   * Constructs a new `BrowserClient` instance.\n   *\n   * @param opts - The options for configuring the browser client.\n   */\n  constructor(opts: CreateBrowserClientOpts) {\n    super(opts);\n    this.baseURL = `https://${opts.frontendHost || \"pipedream.com\"}`;\n    this.iframeURL = `${this.baseURL}/_static/connect.html`;\n    this.tokenCallback = opts.tokenCallback;\n    this.externalUserId = opts.externalUserId;\n  }\n\n  private async token() {\n    if (\n      this._token &&\n      this._tokenExpiresAt &&\n      this._tokenExpiresAt > new Date()\n    ) {\n      return this._token;\n    }\n\n    if (this._tokenRequest) {\n      return this._tokenRequest;\n    }\n\n    const tokenCallback = this.tokenCallback;\n    const externalUserId = this.externalUserId;\n\n    if (!tokenCallback) {\n      throw new Error(\"No token callback provided\");\n    }\n    if (!externalUserId) {\n      throw new Error(\"No external user ID provided\");\n    }\n\n    // Ensure only one token request is in-flight at a time.\n    this._tokenRequest = (async () => {\n      const {\n        token, expires_at,\n      } = await tokenCallback({\n        externalUserId: externalUserId,\n      });\n      this._token = token;\n      this._tokenExpiresAt = new Date(expires_at);\n      this._tokenRequest = undefined;\n      return token;\n    })();\n\n    return this._tokenRequest;\n  }\n\n  private refreshToken() {\n    this._token = undefined;\n  }\n\n  /**\n   * Retrieves the raw token string.\n   *\n   * @return {string} The raw token value.\n   */\n  public rawToken(): string | undefined {\n    return this._token;\n  }\n\n  /**\n   * Initiates the process of connecting an account.\n   *\n   * @param opts - The options for starting the connection process.\n   *\n   * @example\n   * ```typescript\n   * client.connectAccount({\n   *   token: \"your-token\",\n   *   app: \"your-app-id\",\n   *   onSuccess: (res) => {\n   *     console.log(\"Connected account ID:\", res.id);\n   *   },\n   *   onError: (err) => {\n   *     console.error(\"Connection error:\", err);\n   *   },\n   *   onClose: (status) => {\n   *     if (!status.successful) {\n   *       console.log(\"User closed without connecting\");\n   *     }\n   *   },\n   * });\n   * ```\n   */\n  public async connectAccount(opts: StartConnectOpts) {\n    let connectionSuccessful = false;\n    let connectionCompleted = false;\n\n    const onMessage = (e: MessageEvent) => {\n      switch (e.data?.type) {\n      case \"success\":\n        connectionSuccessful = true;\n        connectionCompleted = true;\n        opts.onSuccess?.({\n          id: e.data?.authProvisionId,\n        });\n        break;\n      case \"error\":\n        connectionCompleted = true;\n        opts.onError?.(new ConnectError(e.data.error));\n        break;\n      case \"close\":\n        this.cleanup(onMessage);\n        opts.onClose?.({\n          successful: connectionSuccessful,\n          completed: connectionCompleted,\n        });\n        break;\n      default:\n        break;\n      }\n    };\n\n    window.addEventListener(\"message\", onMessage);\n\n    try {\n      await this.createIframe(opts);\n    } catch (err) {\n      opts.onError?.(err as ConnectError);\n    }\n    this.refreshToken(); // token expires once it's used to create a connected account. We need to get a new token for the next requests.\n  }\n\n  /**\n   * Cleans up the iframe and message event listener after the connection\n   * process is complete.\n   *\n   * @param onMessage - The message event handler to remove.\n   */\n  private cleanup(onMessage: (e: MessageEvent) => void) {\n    this.iframe?.remove();\n    window.removeEventListener(\"message\", onMessage);\n  }\n\n  /**\n   * Creates an iframe for the connection process and appends it to the document\n   * body.\n   *\n   * @param opts - The options for starting the connection process.\n   *\n   * @throws {ConnectError} If the app option is not a string.\n   */\n  private async createIframe(opts: StartConnectOpts) {\n    const token = opts.token || (await this.token());\n    const qp = new URLSearchParams({\n      token,\n    });\n\n    if (typeof opts.app === \"string\") {\n      qp.set(\"app\", opts.app);\n    } else {\n      throw new ConnectError(\"Object app not yet supported\");\n    }\n\n    if (opts.oauthAppId) {\n      qp.set(\"oauthAppId\", opts.oauthAppId);\n    }\n\n    const iframe = document.createElement(\"iframe\");\n    iframe.id = `pipedream-connect-iframe-${this.iframeId++}`;\n    iframe.title = \"Pipedream Connect\";\n    iframe.src = `${this.iframeURL}?${qp.toString()}`;\n    iframe.style.cssText =\n      \"position:fixed;inset:0;z-index:2147483647;border:0;display:block;overflow:hidden auto\";\n    iframe.width = \"100%\";\n    iframe.height = \"100%\";\n\n    iframe.onload = () => {\n      this.iframe = iframe;\n    };\n\n    document.body.appendChild(iframe);\n  }\n\n  protected async authHeaders(): Promise<string> {\n    if (!(await this.token())) {\n      throw new Error(\"No token provided\");\n    }\n    return `Bearer ${await this.token()}`;\n  }\n\n  public getAccounts(\n    params?: Omit<GetAccountOpts, \"external_user_id\">,\n  ): Promise<AccountsRequestResponse> {\n    return super.getAccounts(params);\n  }\n}\n","// DO NOT EDIT, SET AT BUILD TIME\nexport const version = \"1.6.9\"\n","// This code is meant to be shared between the browser and server.\nimport type {\n  ConfigurableProps,\n  ConfiguredProps,\n  V1Component,\n  V1DeployedComponent,\n  V1EmittedEvent,\n} from \"./component.js\";\nexport * from \"./component.js\";\nimport { version as sdkVersion } from \"../version.js\";\n\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> =\n    Pick<T, Exclude<keyof T, Keys>>\n    & {\n        [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n    }[Keys]\n\n// Using `RequireAtLeastOne` here prevents the renaming of the attribute to\n// break existing SDK users, by keeping the old attribute name, while ensuring\n// that at least one of the two attributes is present.\ntype ExternalUserId = RequireAtLeastOne<{\n  /**\n   * Your end user ID, for whom you're configuring the component.\n   */\n  externalUserId: string;\n\n  /**\n   * @deprecated Use `externalUserId` instead.\n   */\n  userId: string;\n}, \"externalUserId\" | \"userId\">;\n\ntype RequestInit = globalThis.RequestInit;\n\n/**\n * Options for creating a server-side client.\n * This is used to configure the BackendClient instance.\n */\nexport type ClientOpts = {\n  /**\n   * The environment in which the server client is running (e.g., \"production\",\n   * \"development\").\n   */\n  environment?: string;\n\n  /**\n   * The API host URL. Used by Pipedream employees. Defaults to\n   * \"api.pipedream.com\" if not provided.\n   */\n  apiHost?: string;\n\n  /**\n   * Base domain for workflows. Used for custom domains:\n   * https://pipedream.com/docs/workflows/domains\n   */\n  workflowDomain?: string;\n};\n\n/**\n * Basic ID information of a Pipedream app.\n */\nexport type AppInfo = {\n  /**\n   * ID of the app. Only applies for OAuth apps.\n   */\n  id?: string;\n\n  /**\n   * The name slug of the target app (see\n   * https://pipedream.com/docs/connect/quickstart#find-your-apps-name-slug)\n   */\n  name_slug: string;\n};\n\n/**\n * The types of authentication that Pipedream apps support.\n */\nexport enum AppAuthType {\n  OAuth = \"oauth\",\n  Keys = \"keys\",\n  None = \"none\",\n}\n\n/**\n * Response object for a Pipedream app's metadata\n */\nexport type App = AppInfo & {\n  /**\n   * The human-readable name of the app.\n   */\n  name: string;\n\n  /**\n   * A short description of the app.\n   */\n  description: string;\n\n  /**\n   * The authentication type used by the app.\n   */\n  auth_type: AppAuthType;\n\n  /**\n   * The URL to the app's logo.\n   */\n  img_src: string;\n\n  /**\n   * A JSON string representing the custom fields for the app.\n   */\n  custom_fields_json: string;\n\n  /**\n   * Categories associated with the app.\n   */\n  categories: string[];\n\n  /**\n   * A rough directional ordering of app popularity, subject to changes by Pipedream.\n   */\n  featured_weight: number\n};\n\n/**\n * @deprecated Use `App` instead.\n */\nexport type AppResponse = App;\n\n/**\n * A configuration option for a component's prop.\n */\nexport type PropOption = {\n  label: string;\n  value: string;\n};\n\ntype ConfigureComponentContext = Record<string, unknown>\n\n/**\n * The response received after configuring a component's prop.\n */\nexport type ConfigureComponentResponse = {\n  /**\n   * The options for the prop that's being configured. This field is applicable\n   * when the values don't nicely map to a descriptive string. Useful when the\n   * values for each option are meaningless numeric IDs, unless mapped to a\n   * human-readable string.\n   *\n   * @example a branch with ID `21208123` and name `my-repo/foo` in a Gitlab\n   * repo\n   * ```json\n   * {\n   *   \"label\": \"my-repo/foo\",\n   *   \"value\": 21208123\n   * }\n   * ```\n   */\n  options: PropOption[];\n\n  /**\n   * The options for the prop that's being configured. This field is applicable\n   * when the values themselves are already human-readable strings.\n   */\n  stringOptions: string[];\n\n  /**\n   * A list of errors that occurred during the configuration process.\n   */\n  errors: string[];\n\n  /**\n   * The context object resolved in the options execution (useful for pagination, etc.).\n   * See {@link ConfigureComponentOpts.prevContext}.\n   */\n  context?: ConfigureComponentContext\n};\n\n/**\n * Attributes to use for pagination in API requests.\n */\nexport type RelationOpts = {\n  /**\n   * The retrieve records starting from a certain cursor.\n   */\n  after?: string;\n\n  /**\n   * To retrieve records up until a certain cursor.\n   */\n  before?: string;\n\n  /**\n   * The maximum number of records to retrieve.\n   */\n  limit?: number;\n};\n\n/**\n * Pagination attributes for API responses.\n */\nexport type ResponsePageInfo = {\n  /**\n   * The total number of records available.\n   */\n  total_count: number;\n\n  /**\n   * The number of records returned in the current response.\n   */\n  count: number;\n\n  /**\n   * The cursor to retrieve the next page of records.\n   */\n  start_cursor: string;\n\n  /**\n   * The cursor of the last page of records.\n   */\n  end_cursor: string;\n};\n\n/**\n * The response attributes for paginated API responses.\n */\nexport type PaginationResponse = {\n  /**\n   * The pagination information for the response.\n   */\n  page_info: ResponsePageInfo;\n}\n\n/**\n * @deprecated Use `ConfigureComponentResponse` instead.\n */\nexport type ComponentConfigureResponse = ConfigureComponentResponse;\n\n/**\n * Parameters for the retrieval of apps from the Connect API\n */\nexport type GetAppsOpts = RelationOpts & {\n  /**\n   * A search query to filter the apps.\n   */\n  q?: string;\n  /**\n   * Filter by whether apps have actions in the component registry.\n   */\n  hasActions?: boolean;\n  /**\n   * Filter by whether apps have components in the component registry.\n   */\n  hasComponents?: boolean;\n  /**\n   * Filter by whether apps have triggers in the component registry.\n   */\n  hasTriggers?: boolean;\n};\n\n/**\n * Parameters for the retrieval of accounts from the Connect API\n */\nexport type GetAccountOpts = RelationOpts & {\n  /**\n   * The ID or name slug of the app, in case you want to only retrieve the\n   * accounts for a specific app.\n   */\n  app?: string;\n\n  /**\n   * The ID of the app (if it's an OAuth app), in case you want to only retrieve\n   * the accounts for a specific app.\n   */\n  oauth_app_id?: string;\n\n  /**\n   * Whether to retrieve the account's credentials or not.\n   */\n  include_credentials?: boolean;\n\n  /**\n   * The external user ID associated with the account.\n   */\n  external_user_id?: string;\n};\n\n/**\n * End user account data, returned from the API.\n */\nexport type Account = {\n  /**\n   * The unique ID of the account.\n   */\n  id: string;\n\n  /**\n   * The name of the account.\n   */\n  name: string;\n\n  /**\n   * The external ID associated with the account.\n   */\n  external_id: string;\n\n  /**\n   * Indicates if the account is healthy. Pipedream will periodically retry\n   * token refresh and test requests for unhealthy accounts.\n   */\n  healthy: boolean;\n\n  /**\n   * Indicates if the account is no longer active.\n   */\n  dead: boolean;\n\n  /**\n   * The app associated with the account.\n   */\n  app: AppResponse;\n\n  /**\n   * The date and time the account was created, an ISO 8601 formatted string.\n   */\n  created_at: string;\n\n  /**\n   * The date and time the account was last updated, an ISO 8601 formatted\n   * string.\n   */\n  updated_at: string;\n\n  /**\n   * The credentials associated with the account, if the `include_credentials`\n   * parameter was set to true in the request.\n   */\n  credentials?: Record<string, string>;\n};\n\n/**\n * The request options for reloading a component's props when dealing with\n * dynamic props.\n */\nexport type ReloadComponentPropsOpts = ExternalUserId & {\n  /**\n   * The ID of the component you're configuring. This is the key that uniquely\n   * identifies the component.\n   */\n  componentId: string | ComponentId;\n\n  /**\n   * The props that have already been configured for the component. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The ID of the last prop reload (or none when reloading the props for the\n   * first time).\n   */\n  dynamicPropsId?: string;\n};\n\nexport type ReloadComponentPropsResponse = {\n  // XXX observations\n\n  /**\n   * A list of errors that occurred during the prop reloading process.\n   */\n  errors: string[]\n\n  /**\n   * Dynamic props object containing the dynamic props ID and the dynamic\n   * configurable props for the component.\n   */\n  dynamicProps: {\n    id: string\n    configurableProps: ConfigurableProps\n  }\n}\n\n/**\n * @deprecated Use `ReloadComponentPropsOpts` instead.\n */\nexport type ComponentReloadPropsOpts = ReloadComponentPropsOpts;\n\n/**\n * The request options for configuring a component's prop.\n */\nexport type ConfigureComponentOpts = ExternalUserId & {\n  /**\n   * The ID of the component you're configuring. This is the key that uniquely\n   * identifies the component.\n   */\n  componentId: string | ComponentId;\n\n  /**\n   * The name of the prop you're configuring.\n   */\n  propName: string;\n\n  /**\n   * The props that have already been configured for the component. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The ID of the last prop reconfiguration (if any).\n   */\n  dynamicPropsId?: string;\n\n  /**\n   * A string with the user input if the prop has the useQuery property set to\n   * true. Use with APIs that return items based on a query or search parameter.\n   */\n  query?: string;\n\n  /**\n   * A 0 indexed page number. Use with APIs that accept a\n   * numeric page number for pagination.\n   */\n  page?: number;\n\n  /**\n   * The context object from the previous options execution (useful for pagination, etc.).\n   * See {@link ConfigureComponentResponse.context}.\n   */\n  prevContext?: ConfigureComponentContext;\n};\n\n/**\n * @deprecated Use `ConfigureComponentOpts` instead.\n */\nexport type ComponentConfigureOpts = ConfigureComponentOpts;\n\n/**\n * The request options for retrieving a list of components.\n */\nexport type GetComponentsOpts = RelationOpts & {\n  /**\n   * A search query to filter the components.\n   */\n  q?: string;\n\n  /**\n   * The ID or name slug of the app to filter the components.\n   */\n  app?: string;\n\n  /**\n   * The type of component to filter (either \"trigger\" or \"action\").\n   */\n  componentType?: ComponentType;\n};\n\n/**\n * @deprecated Use `GetComponentsOpts` instead.\n */\nexport type GetComponentOpts = GetComponentsOpts;\n\n/**\n * An object that identifies a single, unique component in Pipedream.\n */\nexport type ComponentId = {\n  /**\n   * The key that uniquely identifies the component.\n   *\n   * @example \"gitlab-list-commits\"\n   * @example \"slack-send-message\"\n   */\n  key: string;\n};\n\n/**\n * Components can be either triggers or actions.\n */\nexport type ComponentType = \"trigger\" | \"action\";\n\n/**\n * Response received after creating a connect token.\n */\nexport type ConnectTokenResponse = {\n  /**\n   * The generated token.\n   */\n  token: string;\n\n  /**\n   * The expiration time of the token in ISO 8601 format.\n   */\n  expires_at: string;\n\n  /**\n   * The Connect Link URL\n   */\n  connect_link_url: string;\n};\n\n/**\n * The response received when retrieving a list of accounts.\n */\nexport type GetAccountsResponse = PaginationResponse & {\n  data: Account[];\n};\n\n/**\n * @deprecated Use `GetAccountsResponse` instead.\n */\nexport type AccountsRequestResponse = GetAccountsResponse;\n\n/**\n * The response received when retrieving a list of apps.\n */\nexport type GetAppsResponse = PaginationResponse & {\n  data: App[];\n};\n\n/**\n * @deprecated Use `GetAppsResponse` instead.\n */\nexport type AppsRequestResponse = GetAppsResponse;\n\n/**\n * The response received when retrieving a specific app.\n */\nexport type GetAppResponse = { data: App; };\n\n/**\n * @deprecated Use `GetAppResponse` instead.\n */\nexport type AppRequestResponse = GetAppResponse;\n\n/**\n * The response received when retrieving a list of components.\n */\nexport type GetComponentsResponse = PaginationResponse & {\n  data: V1Component[];\n};\n\n/**\n * @deprecated Use `GetComponentsResponse` instead.\n */\nexport type ComponentsRequestResponse = GetComponentsResponse;\n\n/**\n * The response received when retrieving a specific component.\n */\nexport type GetComponentResponse = { data: V1Component; };\n\n/**\n * @deprecated Use `GetComponentResponse` instead.\n */\nexport type ComponentRequestResponse = GetComponentResponse;\n\n/**\n * The request options for running an action.\n */\nexport type RunActionOpts = ExternalUserId & {\n  /**\n   * The ID of the action you're running. This is the key that uniquely\n   * identifies the action.\n   */\n  actionId: string | ComponentId;\n\n  /**\n   * The props that have already been configured for the action. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The ID of the last prop reconfiguration (if any).\n   */\n  dynamicPropsId?: string;\n\n  /**\n   * The ID of the File Stash to sync the action's /tmp directory with. This\n   * allows you to persist files across action runs for up to 1 day. If set to\n   * `true` or \"\", a unique stash ID will be generated for you and returned in\n   * the response. If not set, the action will not sync its /tmp directory with\n   * a File Stash.\n   */\n  stashId?: string | boolean;\n};\n\n/**\n * The response received after running an action. See\n * https://pipedream.com/docs/components/api#returning-data-from-steps for more\n * details.\n */\nexport type RunActionResponse = {\n  /**\n   * The key-value pairs resulting from calls to `$.export`\n   */\n  exports: unknown;\n\n  /**\n   * Any logs produced during the execution of the action\n   */\n  os: unknown[];\n\n  /**\n   * The value returned by the action\n   */\n  ret: unknown;\n\n  /**\n   * The ID of the File Stash that was used to sync the action's /tmp directory\n   */\n  stashId?: string;\n};\n\n/**\n * The request options for deploying a trigger.\n */\nexport type DeployTriggerOpts = ExternalUserId & {\n  /**\n   * The ID of the trigger you're deploying. This is the key that uniquely\n   * identifies the trigger.\n   */\n  triggerId: string | ComponentId;\n\n  /**\n   * The props that have already been configured for the trigger. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The ID of the last prop reconfiguration (if any).\n   */\n  dynamicPropsId?: string;\n\n  /**\n   * The ID of the workflow that the trigger will use to send the events it\n   * generates.\n   */\n  workflowId?: string;\n\n  /**\n   * The webhook URL that the trigger will use to send the events it generates.\n   */\n  webhookUrl?: string;\n};\n\n/**\n * The response received after deploying a trigger.\n */\nexport type DeployTriggerResponse = {\n  /**\n   * The contents of the deployed trigger.\n   */\n  data: V1DeployedComponent;\n}\n\n/**\n * The request options for deleting a deployed trigger owned by a particular\n * user.\n */\nexport type DeleteTriggerOpts = {\n  /**\n   * The ID of the trigger you're deleting (`dc_xxxxxxx` for example ).\n   */\n  id: string;\n\n  /**\n   * The end user ID, for whom you deployed the trigger.\n   */\n  externalUserId: string;\n\n  /**\n   * When explicitly set, the API will ignore any errors that occur during the\n   * deactivation hook of the trigger, effectively forcing the deletion of the\n   * trigger.\n   */\n  ignoreHookErrors?: boolean;\n};\n\n/**\n * The request options for retrieving a deployed trigger owned by a particular\n * user.\n */\nexport type GetTriggerOpts = {\n  /**\n   * The ID of the trigger you're retrieving.\n   */\n  id: string;\n\n  /**\n   * Your end user ID, for whom you deployed the trigger.\n   */\n  externalUserId: string;\n};\n\n/**\n * The response received after retrieving a deployed trigger.\n */\nexport type GetTriggerResponse = {\n  /**\n   * The contents of the deployed trigger.\n   */\n  data: V1DeployedComponent;\n};\n\n/**\n * The request options for retrieving the events emitted by a deployed trigger.\n */\nexport type GetTriggerEventsOpts = GetTriggerOpts & {\n  /**\n   * The number of events to retrieve (defaults to 20 if not provided).\n   */\n  limit?: number;\n};\n\n/**\n * The response from retrieving the events emitted by a deployed trigger.\n */\nexport type GetTriggerEventsResponse = {\n  /**\n   * The list of events emitted by the trigger.\n   */\n  data: V1EmittedEvent[];\n};\n\n/**\n * The request options for retrieving the workflows that listen to events\n * emitted by a specific trigger.\n */\nexport type GetTriggerWorkflowsOpts = GetTriggerOpts;\n\n/**\n * The response from retrieving the workflows that listen to events emitted by a\n * specific trigger.\n */\nexport type GetTriggerWorkflowsResponse = {\n  /**\n   * The list of workflow IDs that listen to events emitted by the trigger.\n   */\n  workflow_ids: string[];\n};\n\n/**\n * The request options for updating the workflows that listen to events emitted\n * by a specific trigger.\n */\nexport type UpdateTriggerWorkflowsOpts = GetTriggerOpts & {\n  /**\n   * The workflow IDs that should to events emitted by the trigger.\n   */\n  workflowIds: string[];\n}\n\n/**\n * The request options for retrieving the webhooks that listen to events\n * emitted by a specific trigger.\n */\nexport type GetTriggerWebhooksOpts = GetTriggerOpts;\n\n/**\n * The response from retrieving the webhooks that listen to events emitted by a\n * specific trigger.\n */\nexport type GetTriggerWebhooksResponse = {\n  /**\n   * The list of webhook URLs that listen to events emitted by the trigger.\n   */\n  webhook_urls: string[];\n};\n\n/**\n * The request options for updating the webhooks that listen to events emitted\n * by a specific trigger.\n */\nexport type UpdateTriggerWebhooksOpts = GetTriggerOpts & {\n  /**\n   * The webhook URLs that should to events emitted by the trigger.\n   */\n  webhookUrls: string[];\n}\n\n/**\n * The request options for retrieving a list of deployed triggers for a\n * particular user.\n */\nexport type GetTriggersOpts = RelationOpts & {\n  /**\n   * Your end user ID, for whom you deployed the trigger.\n   */\n  externalUserId: string;\n};\n\n/**\n * The response received after retrieving a list of deployed triggers.\n */\nexport type GetTriggersResponse = PaginationResponse & {\n  /**\n   * The list of deployed triggers.\n   */\n  data: V1DeployedComponent[];\n};\n\n/**\n * The request options for updating a trigger.\n */\nexport type UpdateTriggerOpts = {\n  /**\n   * The ID of the trigger you're updating.\n   */\n  id: string;\n\n  /**\n   * Your end user ID, for whom you deployed the trigger.\n   */\n  externalUserId: string;\n\n  /**\n   * The state to which the trigger should be updated.\n   */\n  active?: boolean;\n\n  /**\n   * The props that have already been configured for the trigger. This is a\n   * JSON-serializable object with the prop names as keys and the configured\n   * values as values.\n   */\n  configuredProps?: ConfiguredProps<ConfigurableProps>;\n\n  /**\n   * The new name of the trigger.\n   */\n  name?: string;\n};\n\n/**\n * Different ways in which customers can authorize requests to HTTP endpoints\n */\nexport enum HTTPAuthType {\n  None = \"none\",\n  StaticBearer = \"static_bearer_token\",\n  OAuth = \"oauth\",\n}\n\n/**\n * Error response returned by the API in case of an error.\n */\nexport type ErrorResponse = {\n  /**\n   * The error message returned by the API.\n   */\n  error: string;\n};\n\n/**\n * A generic API response that can either be a success or an error.\n */\nexport type ConnectAPIResponse<T> = T | ErrorResponse;\n\n/**\n * Options for making a request to the Pipedream API.\n */\nexport interface RequestOptions extends Omit<RequestInit, \"headers\" | \"body\"> {\n  /**\n   * Query parameters to include in the request URL.\n   */\n  params?: Record<string, string | boolean | number | null>;\n\n  /**\n   * Headers to include in the request.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * The URL to make the request to.\n   */\n  baseURL?: string;\n\n  /**\n   * The body of the request.\n   */\n  body?: Record<string, unknown> | string | FormData | URLSearchParams | null;\n}\n\nexport interface AsyncRequestOptions extends RequestOptions {\n  body: { async_handle: string; } & Required<RequestOptions[\"body\"]>;\n}\n\nconst SENSITIVE_KEYS = [\n  \"token\",\n  \"password\",\n  \"secret\",\n  \"apiKey\",\n  \"authorization\",\n  \"auth\",\n  \"key\",\n  \"access_token\",\n];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction sanitize(value: any, seen = new WeakSet()): any {\n  if (value === null || value === undefined) return value;\n\n  if (typeof value === \"object\") {\n    if (seen.has(value)) return \"[CIRCULAR]\";\n    seen.add(value);\n\n    if (Array.isArray(value)) {\n      return value.map((v) => sanitize(v, seen));\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const sanitizedObj: Record<string, any> = {};\n    for (const [\n      k,\n      v,\n    ] of Object.entries(value)) {\n      const isSensitiveKey = SENSITIVE_KEYS.some((sensitiveKey) =>\n        k.toLowerCase().includes(sensitiveKey.toLowerCase()));\n      sanitizedObj[k] = isSensitiveKey\n        ? \"[REDACTED]\"\n        : sanitize(v, seen);\n    }\n    return sanitizedObj;\n  }\n\n  return value; // numbers, booleans, functions, etc.\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function DEBUG(...args: any[]) {\n  if (\n    typeof process !== \"undefined\" &&\n    typeof process.env !== \"undefined\" &&\n    process.env.PD_SDK_DEBUG === \"true\"\n  ) {\n    const safeArgs = args.map((arg) => sanitize(arg));\n    console.log(\"[PD_SDK_DEBUG]\", ...safeArgs);\n  }\n}\n\n/**\n * A client for interacting with the Pipedream Connect API on the server-side.\n */\nexport abstract class BaseClient {\n  version = sdkVersion;\n  protected apiHost: string;\n  protected readonly baseApiUrl: string;\n  protected environment: string;\n  protected projectId?: string;\n  protected readonly workflowDomain: string;\n\n  /**\n   * Constructs a new BackendClient instance.\n   *\n   * @param opts - The options for configuring the server client.\n   */\n  constructor(opts: ClientOpts) {\n    this.environment = opts.environment ?? \"production\";\n\n    const {\n      apiHost = \"api.pipedream.com\",\n      workflowDomain = \"m.pipedream.net\",\n    } = opts;\n    this.apiHost = apiHost;\n    this.baseApiUrl = `https://${apiHost}/v1`;\n    this.workflowDomain = workflowDomain;\n  }\n\n  /**\n   * Retrieves the current environment the client is configured to use.\n   * @returns {string} The current environment.\n   */\n  public getEnvironment(): string {\n    return this.environment;\n  }\n\n  /**\n   * Makes an HTTP request\n   *\n   * @template T - The expected response type.\n   * @param path - The API endpoint path.\n   * @param opts - The options for the request.\n   * @returns A promise resolving to the API response.\n   * @throws Will throw an error if the response status is not OK.\n   */\n  public async makeRequest<T>(\n    path: string,\n    opts: RequestOptions = {},\n  ): Promise<T> {\n    const {\n      params,\n      headers: customHeaders,\n      body,\n      method = \"GET\",\n      baseURL = this.baseApiUrl,\n      ...fetchOpts\n    } = opts;\n\n    const url = new URL(`${baseURL}${path}`);\n\n    if (params) {\n      for (const [\n        key,\n        value,\n      ] of Object.entries(params)) {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      }\n    }\n\n    const headers: Record<string, string> = {\n      ...customHeaders,\n      \"X-PD-SDK-Version\": sdkVersion,\n      \"X-PD-Environment\": this.environment,\n    };\n\n    let processedBody: string | URLSearchParams | FormData | null = null;\n\n    if (body) {\n      if (\n        body instanceof FormData ||\n        body instanceof URLSearchParams ||\n        typeof body === \"string\"\n      ) {\n        // For FormData, URLSearchParams, or strings, pass the body as-is\n        processedBody = body;\n      } else {\n        // For objects, assume it's JSON and serialize it\n        processedBody = JSON.stringify(body);\n        // Set the Content-Type header to application/json if not already set\n        headers[\"Content-Type\"] = headers[\"Content-Type\"] || \"application/json\";\n      }\n    }\n\n    const requestOptions: RequestInit = {\n      method,\n      headers,\n      ...fetchOpts,\n    };\n\n    if (\n      [\n        \"POST\",\n        \"PUT\",\n        \"PATCH\",\n      ].includes(method.toUpperCase()) &&\n      processedBody\n    ) {\n      requestOptions.body = processedBody;\n    }\n\n    const response: Response = await fetch(url.toString(), requestOptions);\n\n    const rawBody = await response.text();\n\n    DEBUG(\"status: \", response.status)\n    DEBUG(\"url: \", url.toString())\n    DEBUG(\"requestOptions: \", requestOptions)\n    DEBUG(\"rawBody: \", rawBody)\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}, body: ${rawBody}`);\n    }\n\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && contentType.includes(\"application/json\")) {\n      try {\n        const json = JSON.parse(rawBody);\n        return json as T;\n      } catch (err) {\n        DEBUG(\"Couldn't parse json, falling back to raw\", err)\n      }\n    }\n\n    return rawBody as unknown as T;\n  }\n\n  protected abstract authHeaders(): string | Promise<string>;\n\n  /**\n   * Makes a request to the Pipedream API with appropriate authorization.\n   *\n   * @template T - The expected response type.\n   * @param path - The API endpoint path.\n   * @param opts - The options for the request.\n   * @returns A promise resolving to the API response.\n   * @throws Will throw an error if the response status is not OK.\n   */\n  public async makeAuthorizedRequest<T>(\n    path: string,\n    opts: RequestOptions = {},\n  ): Promise<T> {\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      ...opts.headers,\n      \"Authorization\": await this.authHeaders(),\n    };\n\n    return this.makeRequest(path, {\n      ...opts,\n      headers,\n    });\n  }\n\n  /**\n   * Makes a request to the Connect API using Connect authorization.\n   *\n   * @template T - The expected response type.\n   * @param path - The API endpoint path.\n   * @param opts - The options for the request.\n   * @returns A promise resolving to the API response.\n   */\n  protected makeConnectRequest<T>(\n    path: string,\n    opts: RequestOptions = {},\n  ): Promise<T> {\n    let fullPath = \"/connect\";\n    if (this.projectId) {\n      fullPath += `/${this.projectId}`;\n    }\n    fullPath += path;\n    return this.makeAuthorizedRequest(fullPath, opts);\n  }\n\n  /**\n   * Retrieves the list of accounts associated with the project.\n   *\n   * @param params - The query parameters for retrieving accounts.\n   * @returns A promise resolving to a list of accounts.\n   *\n   * @example\n   * ```typescript\n   * const accounts = await client.getAccounts({ include_credentials: true });\n   * console.log(accounts);\n   * ```\n   */\n  public getAccounts(params: GetAccountOpts = {}) {\n    return this.makeConnectRequest<GetAccountsResponse>(\"/accounts\", {\n      method: \"GET\",\n      params,\n    });\n  }\n\n  /**\n   * Retrieves the list of apps available in Pipedream.\n   *\n   * @param opts - The options for retrieving apps.\n   * @returns A promise resolving to a list of apps.\n   *\n   * @example\n   * ```typescript\n   * const apps = await client.getApps({ q: \"slack\" });\n   * console.log(apps);\n   * ```\n   */\n  public getApps(opts?: GetAppsOpts) {\n    const params: Record<string, string> = {};\n    if (opts?.q) {\n      params.q = opts.q;\n    }\n    if (opts?.hasActions != null) {\n      params.has_actions = opts.hasActions\n        ? \"1\"\n        : \"0\";\n    }\n    if (opts?.hasComponents != null) {\n      params.has_components = opts.hasComponents\n        ? \"1\"\n        : \"0\";\n    }\n    if (opts?.hasTriggers != null) {\n      params.has_triggers = opts.hasTriggers\n        ? \"1\"\n        : \"0\";\n    }\n\n    this.addRelationOpts(params, opts);\n    return this.makeAuthorizedRequest<GetAppsResponse>(\n      \"/apps\",\n      {\n        method: \"GET\",\n        params,\n      },\n    );\n  }\n\n  /**\n   * @deprecated Use `getApps` instead.\n   */\n  public apps(opts?: GetAppsOpts) {\n    return this.getApps(opts);\n  }\n\n  /**\n   * Retrieves the metadata for a specific app.\n   *\n   * @param idOrNameSlug - The ID or name slug of the app.\n   * @returns A promise resolving to the app metadata.\n   *\n   * @example\n   * ```typescript\n   * const app = await client.getApp(\"slack\");\n   * console.log(app);\n   * ```\n   */\n  public getApp(idOrNameSlug: string) {\n    const url = `/apps/${idOrNameSlug}`;\n    return this.makeAuthorizedRequest<GetAppResponse>(url, {\n      method: \"GET\",\n    });\n  }\n\n  /**\n   * @deprecated Use `getApp` instead.\n   */\n  public app(idOrNameSlug: string) {\n    return this.getApp(idOrNameSlug);\n  }\n\n  /**\n   * Retrieves the list of components available in Pipedream.\n   *\n   * @param opts - The options for retrieving components.\n   * @returns A promise resolving to a list of components.\n   *\n   * @example\n   * ```typescript\n   * const components = await client.getComponents({ q: \"slack\" });\n   * console.log(components);\n   * ```\n   */\n  public getComponents(opts?: GetComponentsOpts) {\n    const params: Record<string, string> = {};\n    if (opts?.app) {\n      params.app = opts.app;\n    }\n    if (opts?.q) {\n      params.q = opts.q;\n    }\n    this.addRelationOpts(params, opts, 20);\n    // XXX can just use /components and ?type instead when supported\n    let path = \"/components\";\n    if (opts?.componentType === \"trigger\") {\n      path = \"/triggers\";\n    } else if (opts?.componentType === \"action\") {\n      path = \"/actions\";\n    }\n    // XXX Is V1Component the correct type for triggers and actions?\n    return this.makeConnectRequest<GetComponentsResponse>(path, {\n      method: \"GET\",\n      params,\n    });\n  }\n\n  /**\n   * @deprecated Use `getComponents` instead.\n   */\n  public components(opts?: GetComponentOpts) {\n    return this.getComponents(opts);\n  }\n\n  /**\n   * Retrieves the metadata for a specific component.\n   *\n   * @param id - The identifier of the component.\n   * @returns A promise resolving to the component metadata.\n   *\n   * @example\n   * ```typescript\n   * const component = await client.getComponent(\"slack-send-message\");\n   * console.log(component);\n   * ```\n   */\n  public getComponent(id: ComponentId) {\n    const { key } = id;\n    const path = `/components/${key}`;\n    return this.makeConnectRequest<GetComponentResponse>(path, {\n      method: \"GET\",\n    });\n  }\n\n  /**\n   * @deprecated Use `getComponent` instead.\n   */\n  public component({ key }: { key: string; }) {\n    return this.getComponent({\n      key,\n    });\n  }\n\n  /**\n   * Configure the next component's prop, based on the current component's\n   * configuration.\n   *\n   * @param opts - The options for configuring the component.\n   * @returns A promise resolving to the response from the configuration.\n   *\n   * @example\n   * ```typescript\n   * const { options } = await client.configureComponent({\n   *  externalUserId: \"jverce\",\n   *  componentId: {\n   *    key: \"slack-send-message\",\n   *  },\n   *  propName: \"channel\",\n   *  configuredProps: {\n   *    slack: {\n    *     authProvisionId: \"apn_z8hD1b4\",\n    *   },\n   *  },\n   * });\n   * console.log(options);\n   */\n  public configureComponent(opts: ConfigureComponentOpts) {\n    const {\n      userId,\n      externalUserId = userId,\n      componentId,\n    } = opts;\n\n    const id = typeof componentId === \"object\"\n      ? componentId.key\n      : componentId;\n\n    const body = {\n      external_user_id: externalUserId,\n      id,\n      prop_name: opts.propName,\n      configured_props: opts.configuredProps,\n      dynamic_props_id: opts.dynamicPropsId,\n      page: opts.page,\n      prev_context: opts.prevContext,\n      query: opts.query,\n    };\n    return this.makeConnectRequest<ConfigureComponentResponse>(\"/components/configure\", {\n      method: \"POST\",\n      body,\n    });\n  }\n\n  /**\n   * @deprecated Use `configureComponent` instead.\n   */\n  public componentConfigure(opts: ComponentConfigureOpts) {\n    return this.configureComponent(opts);\n  }\n\n  /**\n   * Reload the component prop's based on the current component's configuration.\n   * This applies to dynamic props (see the docs for more info:\n   * https://pipedream.com/docs/components/api#dynamic-props).\n   *\n   * @param opts - The options for reloading the component's props.\n   * @returns A promise resolving to the response from the reload.\n   *\n   * @example\n   * ```typescript\n   * const { dynamicProps } = await client.reloadComponentProps({\n   *  externalUserId: \"jverce\",\n   *  componentId: {\n   *    key: \"slack-send-message\",\n   *  },\n   *  configuredProps: {\n   *    slack: {\n   *      authProvisionId: \"apn_z8hD1b4\",\n   *    },\n   *  },\n   * });\n   *\n   * const { configurableProps, id: dynamicPropsId } = dynamicProps;\n   * // Use `dynamicPropsId` to configure the next prop\n   * // Use `configurableProps` to display the new set of props to the user\n   */\n  public reloadComponentProps(opts: ReloadComponentPropsOpts) {\n    const {\n      userId,\n      externalUserId = userId,\n      componentId,\n    } = opts;\n\n    const id = typeof componentId === \"object\"\n      ? componentId.key\n      : componentId;\n\n    // RpcActionReloadPropsInput\n    const body = {\n      external_user_id: externalUserId,\n      id,\n      configured_props: opts.configuredProps,\n      dynamic_props_id: opts.dynamicPropsId,\n    };\n\n    return this.makeConnectRequest<ReloadComponentPropsResponse>(\n      \"/components/props\", {\n      // TODO trigger\n        method: \"POST\",\n        body,\n      },\n    );\n  }\n\n  /**\n   * @deprecated Use `reloadComponentProps` instead.\n   */\n  public componentReloadProps(opts: ComponentReloadPropsOpts) {\n    return this.reloadComponentProps(opts);\n  }\n\n  /**\n   * Invoke an action component for a Pipedream Connect user in a project\n   *\n   * @param opts - The options for running the action.\n   * @returns A promise resolving to the response from the action's execution.\n   *\n   * @example\n   * ```typescript\n   * const response = await client.runAction({\n   *   externalUserId: \"jverce\",\n   *   actionId: {\n   *     key: \"gitlab-list-commits\",\n   *   },\n   *   configuredProps: {\n   *     gitlab: {\n   *       authProvisionId: \"apn_z8hD1b4\"\n   *     },\n   *     projectId: 21208123,\n   *     refName: \"10-0-stable-ee\",\n   *   },\n   * });\n   * console.log(response);\n   * ```\n   */\n  public runAction(opts: RunActionOpts) {\n    const {\n      userId,\n      externalUserId = userId,\n      actionId,\n    } = opts;\n\n    const id = typeof actionId === \"object\"\n      ? actionId.key\n      : actionId;\n\n    const body = {\n      external_user_id: externalUserId,\n      id,\n      configured_props: opts.configuredProps,\n      dynamic_props_id: opts.dynamicPropsId,\n      stash_id: opts.stashId,\n    };\n    return this.makeConnectRequest<RunActionResponse>(\"/actions/run\", {\n      method: \"POST\",\n      body,\n    });\n  }\n\n  /**\n   * @deprecated Use `runAction` instead.\n   */\n  public actionRun(opts: RunActionOpts) {\n    return this.runAction(opts);\n  }\n\n  /**\n   * Deploy a trigger component for a Pipedream Connect user in a project\n   *\n   * @param opts - The options for deploying the trigger.\n   * @returns A promise resolving to the response from the trigger's deployment.\n   *\n   * @example\n   * ```typescript\n   * const response = await client.deployTrigger({\n   *   externalUserId: \"jverce\",\n   *   triggerId: {\n   *     key: \"gitlab-new-issue\",\n   *   },\n   *   configuredProps: {\n   *     gitlab: {\n   *       authProvisionId: \"apn_z8hD1b4\",\n   *     },\n   *     projectId: 21208123,\n   *   },\n   *   webhookUrl: \"https://dest.mydomain.com\",\n   * });\n   * console.log(response);\n   */\n  public deployTrigger(opts: DeployTriggerOpts) {\n    const {\n      userId,\n      externalUserId = userId,\n      triggerId,\n    } = opts;\n\n    const id = typeof triggerId === \"object\"\n      ? triggerId.key\n      : triggerId;\n\n    const body = {\n      external_user_id: externalUserId,\n      id,\n      configured_props: opts.configuredProps,\n      dynamic_props_id: opts.dynamicPropsId,\n      workflow_id: opts.workflowId,\n      webhook_url: opts.webhookUrl,\n    };\n    return this.makeConnectRequest<DeployTriggerResponse>(\"/triggers/deploy\", {\n      method: \"POST\",\n      body,\n    });\n  }\n\n  /**\n   * @deprecated Use `deployTrigger` instead.\n   */\n  public triggerDeploy(opts: DeployTriggerOpts) {\n    return this.deployTrigger(opts);\n  }\n\n  /**\n   * Deletes a specific trigger.\n   *\n   * @param opts - The options for deleting the trigger.\n   * @returns No content\n   */\n  public deleteTrigger(opts: DeleteTriggerOpts) {\n    const {\n      id,\n      externalUserId,\n      ignoreHookErrors = null,\n    } = opts;\n\n    return this.makeConnectRequest<void>(`/deployed-triggers/${id}`, {\n      method: \"DELETE\",\n      params: {\n        external_user_id: externalUserId,\n        ignore_hook_errors: ignoreHookErrors,\n      },\n    });\n  }\n\n  /**\n   * Retrieves the metadata for a specific trigger.\n   *\n   * @param opts - The options for retrieving the trigger.\n   * @returns A promise resolving to the trigger metadata.\n   */\n  public getTrigger(opts: GetTriggerOpts) {\n    const {\n      id,\n      externalUserId,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerResponse>(`/deployed-triggers/${id}`, {\n      method: \"GET\",\n      params: {\n        external_user_id: externalUserId,\n      },\n    });\n  }\n\n  /**\n   * Retrieves the metadata for all deployed triggers\n   *\n   * @param opts - The options for retrieving the triggers.\n   * @returns A promise resolving to a list of the trigger metadata.\n   */\n  public getTriggers(opts: GetTriggersOpts) {\n    const { externalUserId } = opts;\n\n    return this.makeConnectRequest<GetTriggersResponse>(\"/deployed-triggers\", {\n      method: \"GET\",\n      params: {\n        external_user_id: externalUserId,\n      },\n    });\n  }\n\n  /**\n   * Updates a specific trigger.\n   *\n   * @param opts - The options for updating the trigger.\n   * @returns A promise resolving to the trigger metadata.\n   */\n  public updateTrigger(opts: UpdateTriggerOpts) {\n    const {\n      id,\n      externalUserId,\n      active = null,\n      configuredProps = null,\n      name = null,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerResponse>(`/deployed-triggers/${id}`, {\n      method: \"PUT\",\n      params: {\n        external_user_id: externalUserId,\n      },\n      body: {\n        active,\n        configured_props: configuredProps,\n        name,\n      },\n    });\n  }\n\n  /**\n   * Retrieves the last events emitted by a specific trigger.\n   *\n   * @param opts - The options for retrieving the trigger events.\n   * @returns A promise resolving to a list of emitted events.\n   */\n  public getTriggerEvents(opts: GetTriggerEventsOpts) {\n    const {\n      id,\n      externalUserId,\n      limit = null,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerEventsResponse>(\n      `/deployed-triggers/${id}/events`, {\n        method: \"GET\",\n        params: {\n          external_user_id: externalUserId,\n          n: limit,\n        },\n      },\n    );\n  }\n\n  /**\n   * Retrieves the list of workflows to which the trigger emits events.\n   *\n   * @param opts - The options for retrieving the listening workflows.\n   * @returns A promise resolving to a list of workflows.\n   */\n  public getTriggerWorkflows(opts: GetTriggerWorkflowsOpts) {\n    const {\n      id,\n      externalUserId,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerWorkflowsResponse>(\n      `/deployed-triggers/${id}/pipelines`, {\n        method: \"GET\",\n        params: {\n          external_user_id: externalUserId,\n        },\n      },\n    );\n  }\n\n  /**\n   * Updates the list of workflows to which the trigger will emit events.\n   *\n   * @param opts - The options for updating the listening workflows.\n   * @throws If `workflowIds` is not an array.\n   * @returns A promise resolving to a list of workflows.\n   */\n  public updateTriggerWorkflows(opts: UpdateTriggerWorkflowsOpts) {\n    const {\n      id,\n      externalUserId,\n      workflowIds,\n    } = opts;\n\n    if (!Array.isArray(workflowIds)) {\n      throw new Error(\"workflowIds must be an array\");\n    }\n\n    return this.makeConnectRequest<GetTriggerWorkflowsResponse>(\n      `/deployed-triggers/${id}/pipelines`, {\n        method: \"PUT\",\n        params: {\n          external_user_id: externalUserId,\n        },\n        body: {\n          workflow_ids: workflowIds,\n        },\n      },\n    );\n  }\n\n  /**\n   * Retrieves the list of webhooks to which the trigger emits events.\n   *\n   * @param opts - The options for retrieving the listening webhooks.\n   * @returns A promise resolving to a list of webhooks.\n   */\n  public getTriggerWebhooks(opts: GetTriggerWebhooksOpts) {\n    const {\n      id,\n      externalUserId,\n    } = opts;\n\n    return this.makeConnectRequest<GetTriggerWebhooksResponse>(\n      `/deployed-triggers/${id}/webhooks`, {\n        method: \"GET\",\n        params: {\n          external_user_id: externalUserId,\n        },\n      },\n    );\n  }\n\n  /**\n   * Updates the list of webhooks to which the trigger will emit events.\n   *\n   * @param opts - The options for updating the listening webhooks.\n   * @throws If `webhookUrls` is not an array.\n   * @returns A promise resolving to a list of webhooks.\n   */\n  public updateTriggerWebhooks(opts: UpdateTriggerWebhooksOpts) {\n    const {\n      id,\n      externalUserId,\n      webhookUrls,\n    } = opts;\n\n    if (!Array.isArray(webhookUrls)) {\n      throw new Error(\"webhookUrls must be an array\");\n    }\n\n    return this.makeConnectRequest<GetTriggerWebhooksResponse>(\n      `/deployed-triggers/${id}/webhooks`, {\n        method: \"PUT\",\n        params: {\n          external_user_id: externalUserId,\n        },\n        body: {\n          webhook_urls: webhookUrls,\n        },\n      },\n    );\n  }\n\n  /**\n   * Builds a full workflow URL based on the input.\n   *\n   * @param input - Either a full URL (with or without protocol) or just an\n   * endpoint ID.\n   * @returns The fully constructed URL.\n   * @throws If the input is a malformed URL, throws an error with a clear\n   * message.\n   *\n   * @example\n   * ```typescript\n   * // Full URL input\n   * this.buildWorkflowUrl(\"https://en123.m.pipedream.net\");\n   * // Returns: \"https://en123.m.pipedream.net\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Partial URL (without protocol)\n   * this.buildWorkflowUrl(\"en123.m.pipedream.net\");\n   * // Returns: \"https://en123.m.pipedream.net\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // ID only input\n   * this.buildWorkflowUrl(\"en123\");\n   * // Returns: \"https://en123.yourdomain.com\" (where `yourdomain.com` is set in `workflowDomain`)\n   * ```\n   */\n  private buildWorkflowUrl(input: string): string {\n    const sanitizedInput = input\n      .trim()\n      .replace(/[^\\w-./:]/g, \"\")\n      .toLowerCase();\n    if (!sanitizedInput) {\n      throw new Error(\"URL or endpoint ID is required\");\n    }\n\n    let url: string;\n    const isUrl =\n      sanitizedInput.includes(\".\") || sanitizedInput.startsWith(\"http\");\n\n    if (isUrl) {\n      // Try to parse the input as a URL\n      let parsedUrl: URL;\n      try {\n        const urlString = sanitizedInput.startsWith(\"http\")\n          ? sanitizedInput\n          : `https://${sanitizedInput}`;\n        parsedUrl = new URL(urlString);\n      } catch {\n        throw new Error(`\n          The provided URL is malformed: \"${sanitizedInput}\".\n          Please provide a valid URL.\n        `);\n      }\n\n      // Validate the hostname to prevent potential DNS rebinding attacks\n      if (!parsedUrl.hostname.endsWith(this.workflowDomain)) {\n        throw new Error(\n          `Invalid workflow domain. URL must end with ${this.workflowDomain}`,\n        );\n      }\n\n      url = parsedUrl.href;\n    } else {\n      // If the input is an ID, construct the full URL using the base domain\n      if (!/^e(n|o)[a-z0-9-]+$/i.test(sanitizedInput)) {\n        throw new Error(`\n          Invalid endpoint ID format.\n          Must contain only letters, numbers, and hyphens, and start with either \"en\" or \"eo\".\n        `);\n      }\n\n      url = `https://${sanitizedInput}.${this.workflowDomain}`;\n    }\n\n    return url;\n  }\n\n  /**\n   * Invokes a workflow using the URL of its HTTP interface(s), by sending an\n   *\n   * @param urlOrEndpoint - The URL of the workflow's HTTP interface, or the ID of the endpoint\n   * @param opts - The options for the request.\n   * @param opts.body - The body of the request. It must be a JSON-serializable\n   * value (e.g. an object, null, a string, etc.).\n   * @param opts.headers - The headers to include in the request. Note that the\n   * Authorization header will always be set with an OAuth access token\n   * retrieved by the client.\n   * @param authType - The type of authorization to use for the request.\n   * @returns A promise resolving to the response from the workflow.\n   *\n   * @example\n   * ```typescript\n   * const response: JSON = await client.invokeWorkflow(\n   *   \"https://en-your-endpoint.m.pipedream.net\",\n   *   {\n   *     body: {\n   *       foo: 123,\n   *       bar: \"abc\",\n   *       baz: null,\n   *     },\n   *     headers: {\n   *       \"Accept\": \"application/json\",\n   *     },\n   *   },\n   *   \"oauth\",\n   * );\n   * console.log(response);\n   * ```\n   */\n  public async invokeWorkflow(\n    urlOrEndpoint: string,\n    opts: RequestOptions = {},\n    authType: HTTPAuthType = HTTPAuthType.None,\n  ): Promise<unknown> {\n    const {\n      body, headers = {},\n    } = opts;\n\n    const url = this.buildWorkflowUrl(urlOrEndpoint);\n\n    let authHeader: string | undefined;\n    switch (authType) {\n    case HTTPAuthType.StaticBearer:\n      // It's expected that users will pass their own Authorization header in\n      // the static bearer case\n      authHeader = headers[\"Authorization\"];\n      break;\n    case HTTPAuthType.OAuth:\n      authHeader = await this.authHeaders(); // TODO How to handle this client side? We should pass the auth even if it's not OAuth\n      break;\n    default:\n      break;\n    }\n\n    return this.makeRequest(\"\", {\n      ...opts,\n      baseURL: url,\n      method: opts.method || \"POST\", // Default to POST if not specified\n      headers: authHeader\n        ? {\n          ...headers,\n          Authorization: authHeader,\n        }\n        : headers,\n      body,\n    });\n  }\n\n  /**\n   * Invokes a workflow for a Pipedream Connect user in a project\n   *\n   * @param url - The URL of the workflow's HTTP interface.\n   * @param externalUserId — Your end user ID, for whom you're invoking the\n   * workflow.\n   * @param opts - The options for the request.\n   * @param opts.body - The body of the request. It must be a JSON-serializable\n   * value (e.g. an object, null, a string, etc.).\n   * @param opts.headers - The headers to include in the request. Note that the\n   * Authorization header will always be set with an OAuth access token\n   * retrieved by the client.\n   * @returns A promise resolving to the response from the workflow.\n   *\n   * @example\n   * ```typescript\n   * const response = await client.invokeWorkflowForExternalUser(\n   *   \"https://your-workflow-url.m.pipedream.net\",\n   *   \"your-external-user-id\",\n   *   {\n   *     body: {\n   *       foo: 123,\n   *       bar: \"abc\",\n   *       baz: null,\n   *     },\n   *     headers: {\n   *       \"Accept\": \"application/json\",\n   *     },\n   *   },\n   * );\n   * console.log(response);\n   * ```\n   */\n  public async invokeWorkflowForExternalUser(\n    url: string,\n    externalUserId: string,\n    opts: RequestOptions = {},\n  ): Promise<unknown> {\n    if (!externalUserId?.trim()) {\n      throw new Error(\"External user ID is required\");\n    }\n\n    if (!url.trim()) {\n      throw new Error(\"Workflow URL is required\");\n    }\n\n    if (!(await this.authHeaders())) {\n      throw new Error(\n        // TODO Test that this works with token auth\n        \"OAuth or token is required for invoking workflows for external users. Please pass credentials for a valid OAuth client\",\n      );\n    }\n\n    const { headers = {} } = opts;\n    return this.invokeWorkflow(\n      url,\n      {\n        ...opts,\n        headers: {\n          ...headers,\n          \"X-PD-External-User-ID\": externalUserId,\n        },\n      },\n      HTTPAuthType.OAuth,\n    ); // OAuth auth is required for invoking workflows for external users\n  }\n\n  private addRelationOpts(params: Record<string, string>, opts?: RelationOpts, defaultLimit?: number) {\n    if (opts?.limit != null) {\n      params.limit = \"\" + opts.limit;\n    }\n    if (defaultLimit != null && !params.limit) {\n      params.limit = \"\" + defaultLimit;\n    }\n    if (opts?.after) {\n      params.after = opts.after;\n    }\n    if (opts?.before) {\n      params.before = opts.before;\n    }\n  }\n}\n"],"mappings":"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","names":["browser_exports","__export","BrowserClient","createFrontendClient","__toCommonJS","version","SENSITIVE_KEYS","sanitize","value","seen","v","sanitizedObj","k","isSensitiveKey","sensitiveKey","DEBUG","args","safeArgs","arg","BaseClient","opts","version","_a","apiHost","workflowDomain","path","params","customHeaders","body","method","baseURL","fetchOpts","__objRest","url","key","headers","__spreadProps","__spreadValues","processedBody","requestOptions","response","rawBody","contentType","err","fullPath","idOrNameSlug","id","userId","externalUserId","componentId","actionId","triggerId","ignoreHookErrors","active","configuredProps","name","limit","workflowIds","webhookUrls","input","sanitizedInput","parsedUrl","urlString","e","urlOrEndpoint","authType","authHeader","defaultLimit","ConnectError","createFrontendClient","opts","BrowserClient","BaseClient","tokenCallback","externalUserId","token","expires_at","_a","connectionSuccessful","connectionCompleted","onMessage","e","_b","_c","_d","_e","err","qp","iframe","params"]}